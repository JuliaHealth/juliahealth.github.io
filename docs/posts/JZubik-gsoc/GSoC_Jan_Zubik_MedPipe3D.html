<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Zubik">
<meta name="dcterms.date" content="2024-11-03">
<meta name="description" content="MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.">

<title>GSoC â€™24: Adding dataset-wide functions and integrations of augmentations â€“ The JuliaHealth Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-67255a26f5bf707586c66d8ca2809a3f.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5949361fc1fda17f19b1028ec5206f52.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "?"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script data-goatcounter="https://juliahealthblog.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="GSoC â€™24: Adding dataset-wide functions and integrations of augmentations â€“ The JuliaHealth Blog">
<meta property="og:description" content="MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.">
<meta property="og:site_name" content="The JuliaHealth Blog">
<meta property="og:locale" content="en_EN">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../profile.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The JuliaHealth Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <span class="nav-link">
<span class="menu-text">Write with Us</span>
    </span>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-join-juliahealth" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Join JuliaHealth</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-join-juliahealth">    
        <li>
    <a class="dropdown-item" href="https://julialang.org/slack/"><i class="bi bi-slack" role="img">
</i> 
 <span class="dropdown-text">Slack (#health-and-medicine)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://julialang.zulipchat.com/"><i class="bi bi-lightning-charge-fill" role="img">
</i> 
 <span class="dropdown-text">Julia Zulip</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://discourse.julialang.org/"><i class="bi bi-pencil-square" role="img">
</i> 
 <span class="dropdown-text">Julia Discourse</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-github" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/JuliaHealth/JuliaHealthBlog">
 <span class="dropdown-text">Source Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose">
 <span class="dropdown-text">Report a Bug</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<b>Navigation &amp; Tips:</b>

<ul>
    <li>Press <b>?</b> for search</li>
    <li><b>"&lt;/&gt; Code"</b> for code nav</li>
</ul>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section">ğŸ“ğŸ©»ğŸ“ğŸ“‰ â¡ï¸ ğŸ—ƒï¸ğŸ“šâ™»ï¸ğŸ§‘â€ğŸ« â¡ï¸ ğŸ¤–ğŸ‘ï¸ğŸ“ˆ â¡ï¸ â¤ï¸â€ğŸ©¹</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  </ul></li>
  <li><a href="#project-goals" id="toc-project-goals" class="nav-link" data-scroll-target="#project-goals">Project Goals</a></li>
  <li><a href="#tasks" id="toc-tasks" class="nav-link" data-scroll-target="#tasks">Tasks</a>
  <ul class="collapse">
  <li><a href="#integrate-augmentations-for-medical-data" id="toc-integrate-augmentations-for-medical-data" class="nav-link" data-scroll-target="#integrate-augmentations-for-medical-data">Integrate augmentations for medical data ğŸ†™</a></li>
  <li><a href="#invertible-augmentations-and-support-test-time-augmentations" id="toc-invertible-augmentations-and-support-test-time-augmentations" class="nav-link" data-scroll-target="#invertible-augmentations-and-support-test-time-augmentations">Invertible augmentations and support test time augmentations ğŸ†™</a></li>
  <li><a href="#patch-based-data-loading-with-probabilistic-oversampling" id="toc-patch-based-data-loading-with-probabilistic-oversampling" class="nav-link" data-scroll-target="#patch-based-data-loading-with-probabilistic-oversampling">Patch-based data loading with probabilistic oversampling âœ…</a></li>
  <li><a href="#calculate-median-and-mean-spacing-with-resampling" id="toc-calculate-median-and-mean-spacing-with-resampling" class="nav-link" data-scroll-target="#calculate-median-and-mean-spacing-with-resampling">Calculate Median and Mean Spacing with resampling ğŸ†™</a></li>
  <li><a href="#basic-post-processing-operations" id="toc-basic-post-processing-operations" class="nav-link" data-scroll-target="#basic-post-processing-operations">Basic Post-processing operations</a></li>
  <li><a href="#structured-configuration-of-all-hyperparameters" id="toc-structured-configuration-of-all-hyperparameters" class="nav-link" data-scroll-target="#structured-configuration-of-all-hyperparameters">Structured configuration of all hyperparameters ğŸ†™</a></li>
  <li><a href="#visualization-of-algorithm-outputs" id="toc-visualization-of-algorithm-outputs" class="nav-link" data-scroll-target="#visualization-of-algorithm-outputs">Visualization of algorithm outputs âš ï¸</a></li>
  <li><a href="#k-fold-cross-validation-functionality" id="toc-k-fold-cross-validation-functionality" class="nav-link" data-scroll-target="#k-fold-cross-validation-functionality">K-fold cross-validation functionality âœ…</a></li>
  </ul></li>
  <li><a href="#conclusions-and-future-development" id="toc-conclusions-and-future-development" class="nav-link" data-scroll-target="#conclusions-and-future-development">Conclusions and Future Development</a></li>
  <li><a href="#future-development" id="toc-future-development" class="nav-link" data-scroll-target="#future-development">Future Development</a>
  <ul class="collapse">
  <li><a href="#necessary-enhancements" id="toc-necessary-enhancements" class="nav-link" data-scroll-target="#necessary-enhancements">Necessary Enhancements</a></li>
  <li><a href="#potential-enhancements" id="toc-potential-enhancements" class="nav-link" data-scroll-target="#potential-enhancements">Potential Enhancements</a></li>
  </ul></li>
  <li><a href="#acknowledgments" id="toc-acknowledgments" class="nav-link" data-scroll-target="#acknowledgments">Acknowledgments ğŸ™‡â€â™‚ï¸</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/edit/main/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">GSoC â€™24: Adding dataset-wide functions and integrations of augmentations</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">gsoc</div>
    <div class="quarto-category">AI/ML</div>
    <div class="quarto-category">imaging</div>
    <div class="quarto-category">gpu</div>
    <div class="quarto-category">analysis</div>
  </div>
  </div>

<div>
  <div class="description">
    MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jan Zubik </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 3, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="section" class="level1">
<h1>ğŸ“ğŸ©»ğŸ“ğŸ“‰ â¡ï¸ ğŸ—ƒï¸ğŸ“šâ™»ï¸ğŸ§‘â€ğŸ« â¡ï¸ ğŸ¤–ğŸ‘ï¸ğŸ“ˆ â¡ï¸ â¤ï¸â€ğŸ©¹</h1>
<p><em>These emoticons may resemble <strong>hieroglyphics</strong>, but very soon you will realize that they <strong>mean more than 1000s</strong> of lines of code.</em></p>
<details>
<summary>
Description of the emojis used in the title
</summary>
<ul>
<li>
ğŸ“ <strong>Action Plan</strong>: A clear, structured plan that guides the setup and configuration of the MedPipe3D pipeline.
</li>
<li>
ğŸ©» <strong>3D Medical Images</strong>: Medical imaging data, such as MRI scans, to be processed and analyzed by the AI model.
</li>
<li>
ğŸ“ <strong>AI Model</strong>: The initial AI model or architecture that will be trained and refined within the pipeline.
</li>
<li>
ğŸ“‰ <strong>Loss Function</strong>: A function that measures the modelâ€™s performance during training, guiding the optimization process.
</li>
<li>
ğŸ—ƒï¸ <strong>Data Loading</strong>: Loading raw data into the pipeline for further processing.
</li>
<li>
ğŸ“š <strong>Data Splitting</strong>: Dividing data into training, validation, and test sets to prepare for model training and evaluation.
</li>
<li>
â™»ï¸ <strong>Data Augmentation</strong>: Increasing data variability through augmentation, enhancing the modelâ€™s generalization capabilities.
</li>
<li>
ğŸ§‘â€ğŸ« <strong>AI Training</strong>: Using the processed data to train the AI model, improving its accuracy and performance.
</li>
<li>
ğŸ¤– <strong>Model</strong>: The trained AI model that can perform tasks such as segmentation on medical images.
</li>
<li>
ğŸ‘ï¸ <strong>Data for Visualization</strong>: Output data, such as masks and segmentations, which can be interpreted directly on medical scans.
</li>
<li>
ğŸ“ˆ <strong>Performance Logs</strong>: Logs and metrics documenting the AIâ€™s performance, ready for further analysis in tools like MedEval3D and MedEye3D.
</li>
<li>
â¤ï¸â€ğŸ©¹ <strong>Purpose of MedPipe3D</strong>: The goal is to create AI tools that assist healthcare professionals in making faster, more accurate decisions, ultimately helping save lives.
</li>
</ul>
</details>
<hr>
<p>In this post, Iâ€™d like to summarize what I did this summer and everything I learned along the way, rebuilding MedPipe3D medical imaging pipeline. I will not start typically, but so that anyone even a novice can visualize what this project has achieved, while the latter part is intended for more experienced readers. It will be easiest to divide it into 4 steps separated by â¡ï¸ in the title above. Each emoji stands for a different piece of pipeliner and will be described below.</p>
<p>ğŸ“ğŸ©»ğŸ“ğŸ“‰ <strong>What we need from the user</strong></p>
<p>MedPipe3D requires four essential inputs from user to get started: a clear action plan ğŸ“, 3D medical images like MRI scans ğŸ©», an AI model ğŸ“, and a loss function ğŸ“‰.</p>
<p>ğŸ—ƒï¸ğŸ“šâ™»ï¸ğŸ§‘â€ğŸ« <strong>The Pipeline essential AI manufacturing line</strong></p>
<p>Following the plan ğŸ“, MedPipe3D loads data, pre-processes and organizes it ğŸ—ƒï¸. Allowing data to be easily split ğŸ“š, efficiently augmented â™»ï¸ in many ways for learning AI ğŸ§‘â€ğŸ« model effectively. In the end performing testing and post processing for better determination of AI skills.<br>
Itâ€™s designed to transform raw medical data into a format that your AI can learn from, segmenting meaningful patterns and structures.</p>
<p>ğŸ¤–ğŸ‘ï¸ğŸ“ˆ <strong>Results and Insights</strong></p>
<p>MedPipe3D is a tool for researchers and for that it cannot do without analysis, testing and evaluation. The result of the pipeline is a model ğŸ¤– as well as data ğŸ‘ï¸ and logs ğŸ“ˆ needed in MedEval3D that are ready for visualization and further analysis with MedEye3D. In a nutshell, it makes visualizing results easy-showing, tumor locations or other medical features directly as masks on the scans.</p>
<p>â¤ï¸â€ğŸ©¹ <strong>Purpose-Driven Technology</strong></p>
<p>MedPipe3Dâ€™s mission goes beyond technology. Itâ€™s about providing the tools to create AIs that support healthcare professionals in making faster, more accurate decisions, with the ultimate goal of saving lives.</p>
<p>This four-part journey captures the heart of MedPipe3D toolkit for advancing medical AI, from raw data to life-saving insight.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><strong>MedPipe3D</strong> is a framework created from hundreds of hours over summer vacation, thousands of lines of code, hundreds mistakes and most importantly the guidance of my mentor and author of all of these libraries Dr.&nbsp;<a href="https://www.linkedin.com/in/jakub-mitura-7b2013151/">Jakub Mitura</a>. At its core, MedPipe3D combines sophisticated data handling from <strong>MedImage</strong> thanks to the hard work of <a href="https://www.linkedin.com/in/divyansh-goyal-34654b200/">Divyansh Goyal</a>. Newly developed pipeline for model training, validation and testing with existing <strong>MedEval3D</strong>, and result visualization with <strong>MedEye3D</strong>. Unfortunately, not all the projectâ€™s goals have been fully achieved, and thereby there is one section â¡ï¸ too many. Hopefully not for long. My name is <a href="https://www.linkedin.com/in/janzubik/">Jan Zubik</a>, and I wrote this entire library from scratch, which is currently my most complex project.</p>
<p>If you are a data scientist, programmer, code enthusiast, I invite you to read the next section where I go into detail and present <strong>version 1</strong> of this tool in detail.</p>
<p>Iâ€™m a 3rd-year student of BSc in Data Science and Machine Learning, I know that many things can be done better, expanded, debugged and optimized. Now it just works, <strong>but donâ€™t hesitate to write to me personally</strong> on <a href="https://www.linkedin.com/in/janzubik/">LinkedIn</a>, <a href="https://julialang.slack.com/team/U06L685B6TD">Juliaâ€™s Slack</a> or <a href="https://github.com/JanZubik">GitHub</a>! With your comments, direct critique <strong>you will help me</strong> to be a better programmer and one day MedPipe3D will contribute in a tiny way to save someoneâ€™s life!</p>
<p>Exact work from the Google Summer of Code project you will find in <a href="https://github.com/JuliaHealth/MedPipe3D.jl/tree/GSoC-'24-MedPipe3D">GitHub the repository.</a></p>
</section>
</section>
<section id="project-goals" class="level1">
<h1>Project Goals</h1>
<p>Primary goal was to develop MedPipe3D and enhance MedImage, a Julia packages designed to streamline the process of GPU-accelerated medical image segmentation. The project aimed to merge existing librariesâ€”MedEye3D, MedEval3D, and MedImageâ€”into a cohesive pipeline that facilitates advanced data handling, preprocessing, augmentation, model training, validation, testing with post-procesing and visualization for medical imaging applications.</p>
</section>
<section id="tasks" class="level1">
<h1>Tasks</h1>
<ul>
<li>ğŸ†™ - Fully finished, with great potential for further development</li>
<li>âœ… - Fully completed</li>
<li>âš ï¸ - Partially uncompleted</li>
<li>âŒ - Unreached</li>
</ul>
Full list of all major parts and minor tasks (all tasks set up in original GSOC plan were complete in at least minimum level, many additional improvments above minimum were implemented)
<details>
<ol type="1">
<li><strong>Helpful functions to support the MedImage format âœ…</strong></li>
</ol>
<ul>
<li>Debugging rotations âœ…</li>
<li>Crop MedImage or 3D array âœ…</li>
<li>Pad MedImage or 3D array âœ…</li>
<li>Pad with edge values âœ…</li>
<li>Calculating the average of the edges of the picture ğŸ†™</li>
</ul>
<ol start="2" type="1">
<li><strong>Integrate Augmentations for Medical Data âœ…</strong></li>
</ol>
<ul>
<li>Brightness transform âœ…</li>
<li>Contrast augmentation transform âœ…</li>
<li>Gamma Transform âœ…</li>
<li>Gaussian noise transform âœ…</li>
<li>Rician noise transform âœ…</li>
<li>Mirror transform âœ…</li>
<li>Scale transform ğŸ†™</li>
<li>Gaussian blur transform âœ…</li>
<li>Simulate low-resolution transform ğŸ†™</li>
<li>Elastic deformation transform ğŸ†™</li>
</ul>
<ol start="3" type="1">
<li><strong>Develop a Pipeline âš ï¸</strong></li>
</ol>
<ul>
<li>Structured configuration of all hyperparameters ğŸ†™</li>
<li>Interactive creation of configuration âœ…</li>
<li>Creating a structured configuration of hyperparameters in JSON ğŸ†™</li>
<li>Loading data into HDF5 âœ…
<ul>
<li>Cropping and padding to real coordinates of the main picture âœ…</li>
<li>Calculate Median and Mean Spacing with resampling ğŸ†™</li>
<li>Cropping and padding to specific or average dimensions âœ…</li>
<li>Standardization and normalization âœ…</li>
</ul></li>
<li>Managing indexes groups (channels) for batche requirements in HDF5 âœ…
<ul>
<li>Divide in to train, validation, test specified as % âœ…</li>
<li>Divide with a specific division specified in JSON âœ…</li>
<li>Equal distribution when there are multiple classes âœ…</li>
</ul></li>
<li>Extracting data and creating 5-dimensional tensors for batched learning âœ…
<ul>
<li>Hole images data loading âœ…</li>
<li>Patch-based data loading with probabilistic oversampling âœ…</li>
</ul></li>
<li>Obtaining the necessary elements for learning âœ…
<ul>
<li>Get optimizer, loss function, performance metrics âœ…</li>
</ul></li>
<li>Apply augmentations âœ…</li>
<li>Train âœ…
<ul>
<li>Initializing model âœ…</li>
<li>The learning epoch âœ…</li>
<li>Epoch with early stopping funcionality âœ…</li>
</ul></li>
<li>Infering âœ…</li>
<li>Validation âœ…
<ul>
<li>Evaluate metric âœ…</li>
<li>Evaluate validation loss âœ…</li>
<li>Validation with largest connected componentâœ…</li>
</ul></li>
<li>Testing âœ…
<ul>
<li>Evaluate test set âœ…</li>
<li>Invertible augmentations evaluation âœ…</li>
<li>Patch-based invertible augmentations evaluation âœ…</li>
</ul></li>
<li>Logging âš ï¸
<ul>
<li>Returning the necessary results âš ï¸</li>
<li>Logging connection to tensorboard âŒ</li>
<li>Logging errors and warnings âŒ</li>
</ul></li>
<li>Visualization âš ï¸
<ul>
<li>Returning data in Nifti format âœ…</li>
<li>Automated visualization in MedEye3D âŒ</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li><strong>Optimize Performance with GPU Acceleration</strong>
<ul>
<li>Augmentations âœ…</li>
<li>Learning, Validation, Testing âœ…</li>
<li>Largest connected component âœ…</li>
</ul></li>
<li><strong>Documentation âš ï¸</strong>
<ul>
<li>Comments in important places in the code âš ï¸</li>
<li>Documentation of the function âš ï¸</li>
<li>Read me âš ï¸</li>
<li>Documentation on juliahealth.org âŒ</li>
</ul></li>
</ol>
</details>
<section id="integrate-augmentations-for-medical-data" class="level2">
<h2 class="anchored" data-anchor-id="integrate-augmentations-for-medical-data">Integrate augmentations for medical data ğŸ†™</h2>
<p>Augmenting medical data is a crucial step for enhancing model robustness, especially given the variations in imaging conditions and patient anatomy.</p>
<ul>
<li>This pipeline currently supports multiple augmentation techniques:
<ul>
<li>Brightness transform âœ…</li>
<li>Contrast augmentation transform âœ…</li>
<li>Gamma Transform âœ…</li>
<li>Gaussian noise transform âœ…</li>
<li>Rician noise transform âœ…</li>
<li>Mirror transform âœ…</li>
<li>Scale transform ğŸ†™</li>
<li>Gaussian blur transform âœ…</li>
<li>Simulate low-resolution transform ğŸ†™</li>
<li>Elastic deformation transform ğŸ†™</li>
</ul></li>
</ul>
<p>Which have been fully integrated. Each of these methods helps the model generalize better by simulating diverse imaging scenarios.</p>
<p><img src="./Augmentations.png" class="img-fluid"></p>
<p>Comments:</p>
<p>Augmentations such as scaling, low-resolution simulation use interpolation that is not yet GPU-accelerated.</p>
<p>Elastic deformation with simulation of different tissue elasticities is are potential development opportunities that would further improve the modelâ€™s adaptability by mimicking more complex variations found in medical imaging.</p>
</section>
<section id="invertible-augmentations-and-support-test-time-augmentations" class="level2">
<h2 class="anchored" data-anchor-id="invertible-augmentations-and-support-test-time-augmentations">Invertible augmentations and support test time augmentations ğŸ†™</h2>
<p>This section focuses on the ability to apply reversible augmentations to test data, allowing the model to be evaluated with different transformations. Only rotation is available at this time. The function <code>evaluate_patches</code> performs this evaluation by applying specified augmentations, dividing the test data into patches, and reconstructing the full image from the patches. During testing one can choose to use of largest connected component post processing. Metrics are calculated and results are saved for analysis.</p>
<details>
<summary>
evaluate_test:
</summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># ...</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="cf">for</span> test_group <span class="kw">in</span> test_groups</span>
<span id="cb1-3"><a href="#cb1-3"></a>    test_data, test_label, attributes <span class="op">=</span> <span class="fu">fetch_and_preprocess_data</span>([test_group], h5, config)</span>
<span id="cb1-4"><a href="#cb1-4"></a>    results, test_metrics <span class="op">=</span> <span class="fu">evaluate_patches</span>(test_data, test_label,  tstate, model, config)</span>
<span id="cb1-5"><a href="#cb1-5"></a>    y_pred, metr <span class="op">=</span> <span class="fu">process_results</span>(results, test_metrics, config)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="fu">save_results</span>(y_pred, attributes, config)</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="fu">push!</span>(all_test_metrics, metr)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="cf">end</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">function</span> <span class="fu">evaluate_patches</span>(test_data, test_label, tstate, model, config, axis, angle)</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="fu">println</span>(<span class="st">"Evaluating patches..."</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>    results <span class="op">=</span> []</span>
<span id="cb2-4"><a href="#cb2-4"></a>    test_metrics <span class="op">=</span> []</span>
<span id="cb2-5"><a href="#cb2-5"></a>    tstates <span class="op">=</span> [tstate]</span>
<span id="cb2-6"><a href="#cb2-6"></a>    test_time_augs <span class="op">=</span> []</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="cf">for</span> i <span class="kw">in</span> config[<span class="st">"learning"</span>][<span class="st">"n_invertible"</span>]</span>
<span id="cb2-9"><a href="#cb2-9"></a>        data <span class="op">=</span> <span class="fu">rotate_mi</span>(test_data, axis, angle)</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="cf">for</span> tstate_curr <span class="kw">in</span> tstates</span>
<span id="cb2-11"><a href="#cb2-11"></a>            patch_results <span class="op">=</span> []</span>
<span id="cb2-12"><a href="#cb2-12"></a>            patch_size <span class="op">=</span> <span class="fu">Tuple</span>(config[<span class="st">"learning"</span>][<span class="st">"patch_size"</span>])</span>
<span id="cb2-13"><a href="#cb2-13"></a>            idx_and_patches, paded_data_size <span class="op">=</span> <span class="fu">divide_into_patches</span>(test_data, patch_size)</span>
<span id="cb2-14"><a href="#cb2-14"></a>            coordinates <span class="op">=</span> [patch[<span class="fl">1</span>] for patch <span class="kw">in</span> idx_and_patches]</span>
<span id="cb2-15"><a href="#cb2-15"></a>            patch_data <span class="op">=</span> [patch[<span class="fl">2</span>] for patch <span class="kw">in</span> idx_and_patches]</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span class="cf">for</span> patch <span class="kw">in</span> patch_data</span>
<span id="cb2-17"><a href="#cb2-17"></a>                y_pred_patch, _ <span class="op">=</span> <span class="fu">infer_model</span>(tstate_curr, model, patch)</span>
<span id="cb2-18"><a href="#cb2-18"></a>                <span class="fu">push!</span>(patch_results, y_pred_patch)</span>
<span id="cb2-19"><a href="#cb2-19"></a>            <span class="cf">end</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>            idx_and_y_pred_patch <span class="op">=</span> <span class="fu">zip</span>(coordinates, patch_results)</span>
<span id="cb2-21"><a href="#cb2-21"></a>            y_pred <span class="op">=</span> <span class="fu">recreate_image_from_patches</span>(idx_and_y_pred_patch, paded_data_size, patch_size, <span class="fu">size</span>(test_data))</span>
<span id="cb2-22"><a href="#cb2-22"></a>            <span class="cf">if</span> config[<span class="st">"learning"</span>][<span class="st">"largest_connected_component"</span>]</span>
<span id="cb2-23"><a href="#cb2-23"></a>                y_pred <span class="op">=</span> <span class="fu">largest_connected_component</span>(y_pred, config[<span class="st">"learning"</span>][<span class="st">"n_lcc"</span>])</span>
<span id="cb2-24"><a href="#cb2-24"></a>            <span class="cf">end</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>            metr <span class="op">=</span> <span class="fu">evaluate_metric</span>(y_pred, test_label, config[<span class="st">"learning"</span>][<span class="st">"metric"</span>])</span>
<span id="cb2-26"><a href="#cb2-26"></a>            <span class="fu">push!</span>(test_metrics, metr)</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">end</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="cf">end</span></span>
<span id="cb2-29"><a href="#cb2-29"></a>    <span class="cf">return</span> results, test_metrics</span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">function</span> <span class="fu">divide_into_patches</span>(image<span class="op">::</span><span class="dt">AbstractArray{T, 5}</span>, patch_size<span class="op">::</span><span class="dt">Tuple{Int, Int, Int}</span>) <span class="kw">where</span> T</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="fu">println</span>(<span class="st">"Dividing image into patches..."</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="fu">println</span>(<span class="st">"Size of the image: "</span>, <span class="fu">size</span>(image)) </span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co"># Calculate the required padding for each dimension (W, H, D)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    pad_size <span class="op">=</span> (</span>
<span id="cb3-7"><a href="#cb3-7"></a>        (<span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">%</span> patch_size[<span class="fl">1</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">1</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">%</span> patch_size[<span class="fl">1</span>] <span class="op">:</span> <span class="fl">0</span>,</span>
<span id="cb3-8"><a href="#cb3-8"></a>        (<span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">%</span> patch_size[<span class="fl">2</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">2</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">%</span> patch_size[<span class="fl">2</span>] <span class="op">:</span> <span class="fl">0</span>,</span>
<span id="cb3-9"><a href="#cb3-9"></a>        (<span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">%</span> patch_size[<span class="fl">3</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">3</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">%</span> patch_size[<span class="fl">3</span>] <span class="op">:</span> <span class="fl">0</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    )</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="co"># Pad the image if necessary</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    padded_image <span class="op">=</span> image</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">if</span> <span class="fu">any</span>(pad_size <span class="op">.&gt;</span> <span class="fl">0</span>)</span>
<span id="cb3-15"><a href="#cb3-15"></a>        padded_image <span class="op">=</span> <span class="fu">crop_or_pad</span>(image, (<span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">+</span> pad_size[<span class="fl">1</span>], <span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">+</span> pad_size[<span class="fl">2</span>], <span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">+</span> pad_size[<span class="fl">3</span>]))</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">end</span></span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="co"># Extract patches</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    patches <span class="op">=</span> []</span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">1</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">1</span>)</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="cf">for</span> y <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">2</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">2</span>)</span>
<span id="cb3-22"><a href="#cb3-22"></a>            <span class="cf">for</span> z <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">3</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">3</span>)</span>
<span id="cb3-23"><a href="#cb3-23"></a>                patch <span class="op">=</span> <span class="fu">view</span>(</span>
<span id="cb3-24"><a href="#cb3-24"></a>                    padded_image,</span>
<span id="cb3-25"><a href="#cb3-25"></a>                    x<span class="op">:</span><span class="fu">min</span>(x<span class="op">+</span>patch_size[<span class="fl">1</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">1</span>)),</span>
<span id="cb3-26"><a href="#cb3-26"></a>                    y<span class="op">:</span><span class="fu">min</span>(y<span class="op">+</span>patch_size[<span class="fl">2</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">2</span>)),</span>
<span id="cb3-27"><a href="#cb3-27"></a>                    z<span class="op">:</span><span class="fu">min</span>(z<span class="op">+</span>patch_size[<span class="fl">3</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">3</span>)),</span>
<span id="cb3-28"><a href="#cb3-28"></a>                    <span class="op">:</span>,</span>
<span id="cb3-29"><a href="#cb3-29"></a>                    <span class="op">:</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>                )</span>
<span id="cb3-31"><a href="#cb3-31"></a>                <span class="fu">push!</span>(patches, [(x, y, z), patch])</span>
<span id="cb3-32"><a href="#cb3-32"></a>            <span class="cf">end</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>        <span class="cf">end</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>    <span class="cf">end</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>    <span class="fu">println</span>(<span class="st">"Size of padded image: "</span>, <span class="fu">size</span>(padded_image))</span>
<span id="cb3-36"><a href="#cb3-36"></a>    <span class="cf">return</span> patches, <span class="fu">size</span>(padded_image)</span>
<span id="cb3-37"><a href="#cb3-37"></a><span class="kw">end</span></span>
<span id="cb3-38"><a href="#cb3-38"></a></span>
<span id="cb3-39"><a href="#cb3-39"></a><span class="kw">function</span> <span class="fu">recreate_image_from_patches</span>(</span>
<span id="cb3-40"><a href="#cb3-40"></a>    coords_with_patches,</span>
<span id="cb3-41"><a href="#cb3-41"></a>    padded_size,</span>
<span id="cb3-42"><a href="#cb3-42"></a>    patch_size,</span>
<span id="cb3-43"><a href="#cb3-43"></a>    original_size</span>
<span id="cb3-44"><a href="#cb3-44"></a>)</span>
<span id="cb3-45"><a href="#cb3-45"></a>    <span class="fu">println</span>(<span class="st">"Recreating image from patches..."</span>)</span>
<span id="cb3-46"><a href="#cb3-46"></a>    reconstructed_image <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float32</span>, padded_size<span class="op">...</span>)</span>
<span id="cb3-47"><a href="#cb3-47"></a>    </span>
<span id="cb3-48"><a href="#cb3-48"></a>    <span class="co"># Place patches back into their original positions</span></span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="cf">for</span> (coords, patch) <span class="kw">in</span> coords_with_patches</span>
<span id="cb3-50"><a href="#cb3-50"></a>        x, y, z <span class="op">=</span> coords</span>
<span id="cb3-51"><a href="#cb3-51"></a>        reconstructed_image[</span>
<span id="cb3-52"><a href="#cb3-52"></a>            x<span class="op">:</span>x<span class="op">+</span>patch_size[<span class="fl">1</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-53"><a href="#cb3-53"></a>            y<span class="op">:</span>y<span class="op">+</span>patch_size[<span class="fl">2</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-54"><a href="#cb3-54"></a>            z<span class="op">:</span>z<span class="op">+</span>patch_size[<span class="fl">3</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-55"><a href="#cb3-55"></a>            <span class="op">:</span>,</span>
<span id="cb3-56"><a href="#cb3-56"></a>            <span class="op">:</span></span>
<span id="cb3-57"><a href="#cb3-57"></a>        ] <span class="op">=</span> patch</span>
<span id="cb3-58"><a href="#cb3-58"></a>    <span class="cf">end</span></span>
<span id="cb3-59"><a href="#cb3-59"></a></span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="co"># Crop the reconstructed image to remove any padding</span></span>
<span id="cb3-61"><a href="#cb3-61"></a>    final_image <span class="op">=</span> reconstructed_image[</span>
<span id="cb3-62"><a href="#cb3-62"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">1</span>],</span>
<span id="cb3-63"><a href="#cb3-63"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">2</span>],</span>
<span id="cb3-64"><a href="#cb3-64"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">3</span>],</span>
<span id="cb3-65"><a href="#cb3-65"></a>        <span class="op">:</span>,</span>
<span id="cb3-66"><a href="#cb3-66"></a>        <span class="op">:</span></span>
<span id="cb3-67"><a href="#cb3-67"></a>    ]</span>
<span id="cb3-68"><a href="#cb3-68"></a>    <span class="fu">println</span>(<span class="st">"Size of the final image: "</span>, <span class="fu">size</span>(final_image))</span>
<span id="cb3-69"><a href="#cb3-69"></a>    <span class="cf">return</span> final_image</span>
<span id="cb3-70"><a href="#cb3-70"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> In this section, there is significant potential to incorporate additional types of invertible augmentations.</p>
</section>
<section id="patch-based-data-loading-with-probabilistic-oversampling" class="level2">
<h2 class="anchored" data-anchor-id="patch-based-data-loading-with-probabilistic-oversampling">Patch-based data loading with probabilistic oversampling âœ…</h2>
<p>In this section, patches are extracted using <code>extract_patch</code> from the medical images for model training, with a probability-based method to decide between a random patch or a patch with non-zero labels. Helper functions like <code>get_random_patch</code> and <code>get_centered_patch</code> determine the starting indices and dimensions for the patches based on given configurations, while padding methods ensure consistency even if the patch exceeds the original image dimensions. Probabilistic oversampling, as configured, allows for more balanced and informative data sampling, which improves the modelâ€™s ability to detect specific medical features.</p>
<details>
<summary>
extract_patch:
</summary>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">function</span> <span class="fu">extract_patch</span>(image, label, patch_size, config)</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="co"># Fetch the oversampling probability from the config</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="fu">println</span>(<span class="st">"Extracting patch."</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>    oversampling_probability <span class="op">=</span> config[<span class="st">"learning"</span>][<span class="st">"oversampling_probability"</span>]</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="co"># Generate a random number to decide which patch extraction method to use</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    random_choice <span class="op">=</span> <span class="fu">rand</span>()</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="cf">if</span> random_choice <span class="op">&lt;=</span> oversampling_probability</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="cf">return</span> <span class="fu">extract_nonzero_patch</span>(image, label, patch_size)</span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="cf">else</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="cf">return</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="cf">end</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="kw">end</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#Helper function, in case the mask is emptyClick to apply</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="kw">function</span> <span class="fu">extract_nonzero_patch</span>(image, label, patch_size)</span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="fu">println</span>(<span class="st">"Extracting a patch centered around a non-zero label value."</span>)</span>
<span id="cb4-18"><a href="#cb4-18"></a>    indices <span class="op">=</span> <span class="fu">findall</span>(x <span class="op">-&gt;</span> x <span class="op">!=</span> <span class="fl">0</span>, label)</span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="cf">if</span> <span class="fu">isempty</span>(indices)</span>
<span id="cb4-20"><a href="#cb4-20"></a>        <span class="co"># Fallback to random patch if no non-zero points are found</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>        <span class="cf">return</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-22"><a href="#cb4-22"></a>    <span class="cf">else</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>        <span class="co"># Choose a random non-zero index to center the patch around</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>        center <span class="op">=</span> indices[<span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(indices))]</span>
<span id="cb4-25"><a href="#cb4-25"></a>        <span class="cf">return</span> <span class="fu">get_centered_patch</span>(image, label, center, patch_size)</span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="cf">end</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="kw">end</span></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="co"># Function to get a patch centered around a specific index</span></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="kw">function</span> <span class="fu">get_centered_patch</span>(image, label, center, patch_size)</span>
<span id="cb4-30"><a href="#cb4-30"></a>    center_coords <span class="op">=</span> <span class="fu">Tuple</span>(center)</span>
<span id="cb4-31"><a href="#cb4-31"></a>    half_patch <span class="op">=</span> patch_size <span class="op">.Ã·</span> <span class="fl">2</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>    start_indices <span class="op">=</span> center_coords <span class="op">.-</span> half_patch</span>
<span id="cb4-33"><a href="#cb4-33"></a>    end_indices <span class="op">=</span> start_indices <span class="op">.+</span> patch_size <span class="op">.-</span> <span class="fl">1</span></span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>    pad_beg <span class="op">=</span> (</span>
<span id="cb4-37"><a href="#cb4-37"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">1</span>], <span class="fl">0</span>),</span>
<span id="cb4-38"><a href="#cb4-38"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">2</span>], <span class="fl">0</span>),</span>
<span id="cb4-39"><a href="#cb4-39"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">3</span>], <span class="fl">0</span>)</span>
<span id="cb4-40"><a href="#cb4-40"></a>    )</span>
<span id="cb4-41"><a href="#cb4-41"></a>    pad_end <span class="op">=</span> (</span>
<span id="cb4-42"><a href="#cb4-42"></a>        <span class="fu">max</span>(end_indices[<span class="fl">1</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">1</span>), <span class="fl">0</span>),</span>
<span id="cb4-43"><a href="#cb4-43"></a>        <span class="fu">max</span>(end_indices[<span class="fl">2</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">2</span>), <span class="fl">0</span>),</span>
<span id="cb4-44"><a href="#cb4-44"></a>        <span class="fu">max</span>(end_indices[<span class="fl">3</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">3</span>), <span class="fl">0</span>)</span>
<span id="cb4-45"><a href="#cb4-45"></a>    )</span>
<span id="cb4-46"><a href="#cb4-46"></a></span>
<span id="cb4-47"><a href="#cb4-47"></a>    <span class="co"># Adjust start_indices and end_indices after padding</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>    start_indices_adj <span class="op">=</span> start_indices <span class="op">.+</span> pad_beg</span>
<span id="cb4-49"><a href="#cb4-49"></a>    end_indices_adj <span class="op">=</span> end_indices <span class="op">.+</span> pad_beg</span>
<span id="cb4-50"><a href="#cb4-50"></a></span>
<span id="cb4-51"><a href="#cb4-51"></a>    <span class="co"># Convert padding values to integers</span></span>
<span id="cb4-52"><a href="#cb4-52"></a>    pad_beg <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">round</span>.(<span class="dt">Int</span>, pad_beg))</span>
<span id="cb4-53"><a href="#cb4-53"></a>    pad_end <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">round</span>.(<span class="dt">Int</span>, pad_end))</span>
<span id="cb4-54"><a href="#cb4-54"></a></span>
<span id="cb4-55"><a href="#cb4-55"></a>    <span class="co"># Pad the image and label using pad_mi</span></span>
<span id="cb4-56"><a href="#cb4-56"></a>    image_padded <span class="op">=</span> <span class="fu">pad_mi</span>(image, pad_beg, pad_end, <span class="fl">0</span>)</span>
<span id="cb4-57"><a href="#cb4-57"></a>    label_padded <span class="op">=</span> <span class="fu">pad_mi</span>(label, pad_beg, pad_end, <span class="fl">0</span>)</span>
<span id="cb4-58"><a href="#cb4-58"></a></span>
<span id="cb4-59"><a href="#cb4-59"></a>    <span class="co"># Extract the patch</span></span>
<span id="cb4-60"><a href="#cb4-60"></a>    image_patch <span class="op">=</span> image_padded[</span>
<span id="cb4-61"><a href="#cb4-61"></a>        start_indices_adj[<span class="fl">1</span>]<span class="op">:</span>end_indices_adj[<span class="fl">1</span>],</span>
<span id="cb4-62"><a href="#cb4-62"></a>        start_indices_adj[<span class="fl">2</span>]<span class="op">:</span>end_indices_adj[<span class="fl">2</span>],</span>
<span id="cb4-63"><a href="#cb4-63"></a>        start_indices_adj[<span class="fl">3</span>]<span class="op">:</span>end_indices_adj[<span class="fl">3</span>]</span>
<span id="cb4-64"><a href="#cb4-64"></a>    ]</span>
<span id="cb4-65"><a href="#cb4-65"></a>    label_patch <span class="op">=</span> label_padded[</span>
<span id="cb4-66"><a href="#cb4-66"></a>        start_indices_adj[<span class="fl">1</span>]<span class="op">:</span>end_indices_adj[<span class="fl">1</span>],</span>
<span id="cb4-67"><a href="#cb4-67"></a>        start_indices_adj[<span class="fl">2</span>]<span class="op">:</span>end_indices_adj[<span class="fl">2</span>],</span>
<span id="cb4-68"><a href="#cb4-68"></a>        start_indices_adj[<span class="fl">3</span>]<span class="op">:</span>end_indices_adj[<span class="fl">3</span>]</span>
<span id="cb4-69"><a href="#cb4-69"></a>    ]</span>
<span id="cb4-70"><a href="#cb4-70"></a></span>
<span id="cb4-71"><a href="#cb4-71"></a>    <span class="cf">return</span> image_patch, label_patch</span>
<span id="cb4-72"><a href="#cb4-72"></a><span class="kw">end</span></span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a><span class="kw">function</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-75"><a href="#cb4-75"></a>    <span class="fu">println</span>(<span class="st">"Extracting a random patch."</span>)</span>
<span id="cb4-76"><a href="#cb4-76"></a>    <span class="co"># Check if the patch size is greater than the image dimensions</span></span>
<span id="cb4-77"><a href="#cb4-77"></a>    <span class="cf">if</span> <span class="fu">any</span>(patch_size <span class="op">.&gt;</span> <span class="fu">size</span>(image))</span>
<span id="cb4-78"><a href="#cb4-78"></a>        <span class="co"># Calculate the needed size to fit the patch</span></span>
<span id="cb4-79"><a href="#cb4-79"></a>        needed_size <span class="op">=</span> <span class="fu">map</span>(max, <span class="fu">size</span>(image), patch_size)</span>
<span id="cb4-80"><a href="#cb4-80"></a>        <span class="co"># Use crop_or_pad to ensure the image and label are at least as large as needed_size</span></span>
<span id="cb4-81"><a href="#cb4-81"></a>        image <span class="op">=</span> <span class="fu">crop_or_pad</span>(image, needed_size)</span>
<span id="cb4-82"><a href="#cb4-82"></a>        label <span class="op">=</span> <span class="fu">crop_or_pad</span>(label, needed_size)</span>
<span id="cb4-83"><a href="#cb4-83"></a>    <span class="cf">end</span></span>
<span id="cb4-84"><a href="#cb4-84"></a></span>
<span id="cb4-85"><a href="#cb4-85"></a>    <span class="co"># Calculate random start indices within the new allowable range</span></span>
<span id="cb4-86"><a href="#cb4-86"></a>    start_x <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">-</span> patch_size[<span class="fl">1</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-87"><a href="#cb4-87"></a>    start_y <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">-</span> patch_size[<span class="fl">2</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-88"><a href="#cb4-88"></a>    start_z <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">-</span> patch_size[<span class="fl">3</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-89"><a href="#cb4-89"></a>    start_indices <span class="op">=</span> [start_x, start_y, start_z]</span>
<span id="cb4-90"><a href="#cb4-90"></a>    end_indices <span class="op">=</span> start_indices <span class="op">.+</span> patch_size <span class="op">.-</span> <span class="fl">1</span></span>
<span id="cb4-91"><a href="#cb4-91"></a></span>
<span id="cb4-92"><a href="#cb4-92"></a>    <span class="co"># Extract the patch directly when within bounds</span></span>
<span id="cb4-93"><a href="#cb4-93"></a>    image_patch <span class="op">=</span> image[start_indices[<span class="fl">1</span>]<span class="op">:</span>end_indices[<span class="fl">1</span>], start_indices[<span class="fl">2</span>]<span class="op">:</span>end_indices[<span class="fl">2</span>], start_indices[<span class="fl">3</span>]<span class="op">:</span>end_indices[<span class="fl">3</span>]]</span>
<span id="cb4-94"><a href="#cb4-94"></a>    label_patch <span class="op">=</span> label[start_indices[<span class="fl">1</span>]<span class="op">:</span>end_indices[<span class="fl">1</span>], start_indices[<span class="fl">2</span>]<span class="op">:</span>end_indices[<span class="fl">2</span>], start_indices[<span class="fl">3</span>]<span class="op">:</span>end_indices[<span class="fl">3</span>]]</span>
<span id="cb4-95"><a href="#cb4-95"></a></span>
<span id="cb4-96"><a href="#cb4-96"></a>    <span class="cf">return</span> image_patch, label_patch</span>
<span id="cb4-97"><a href="#cb4-97"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="calculate-median-and-mean-spacing-with-resampling" class="level2">
<h2 class="anchored" data-anchor-id="calculate-median-and-mean-spacing-with-resampling">Calculate Median and Mean Spacing with resampling ğŸ†™</h2>
<p>This part ensures that all images in the dataset have consistent real coordinates, spacing, shape. Itâ€™s a critical factor in medical imaging for accurate analysis. By calculating and applying set values, median or mean across images ensures uniformity.</p>
<section id="resample-images-to-target-image" class="level4">
<h4 class="anchored" data-anchor-id="resample-images-to-target-image">Resample images to target image ğŸ†™</h4>
<p>This step aligns each image to the reference coordinates main image, ensuring that all images share a common spatial alignment. The <code>resample_to_image</code> function from MedImage.jl is used here, applying interpolation to adjust each image.</p>
<details>
<summary>
resample_images_to_target:
</summary>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1"></a><span class="cf">if</span> resample_images_to_target <span class="op">&amp;&amp;</span> !<span class="fu">isempty</span>(Med_images)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="fu">println</span>(<span class="st">"Resampling </span><span class="sc">$</span>channel_type<span class="st"> files in channel '</span><span class="sc">$</span>channel_folder<span class="st">' to the first </span><span class="sc">$</span>channel_type<span class="st"> in the channel."</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>    reference_image <span class="op">=</span> Med_images[<span class="fl">1</span>]</span>
<span id="cb5-4"><a href="#cb5-4"></a>    Med_images <span class="op">=</span> [<span class="fu">resample_to_image</span>(reference_image, img, interpolator) for img <span class="kw">in</span> Med_images]</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> <code>Resample_to_image</code> uses interpolation that is not yet GPU-accelerated in this implementation, this step slow down the data preparation phase significantly.</p>
</section>
<section id="ensure-uniform-spacing-across-the-entire-dataset" class="level4">
<h4 class="anchored" data-anchor-id="ensure-uniform-spacing-across-the-entire-dataset">Ensure uniform spacing across the entire dataset ğŸ†™</h4>
<p>This step brings all images to a consistent voxel spacing across the dataset using <code>resample_to_spacing</code> from MedImage.jl. This uniform spacing is crucial for creating a standardized dataset where each image voxel represents the same physical volume.</p>
<details>
<summary>
esample_to_spacing:
</summary>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">if</span> resample_images_spacing <span class="op">==</span> <span class="st">"set"</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="fu">println</span>(<span class="st">"Resampling all </span><span class="sc">$</span>channel_type<span class="st"> files to target spacing: </span><span class="sc">$</span>target_spacing<span class="st">"</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a>    target_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(s) <span class="cf">for</span> s <span class="kw">in</span> target_spacing)</span>
<span id="cb6-4"><a href="#cb6-4"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, target_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="st">"avg"</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="fu">println</span>(<span class="st">"Calculating average spacing across all </span><span class="sc">$</span>channel_type<span class="st"> files and resampling."</span>)</span>
<span id="cb6-7"><a href="#cb6-7"></a>    all_spacings <span class="op">=</span> [img.spacing for channel <span class="kw">in</span> channels_data for img <span class="kw">in</span> channel]</span>
<span id="cb6-8"><a href="#cb6-8"></a>    avg_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(<span class="fu">mean</span>(s)) <span class="cf">for</span> s <span class="kw">in</span> <span class="fu">zip</span>(all_spacings<span class="op">...</span>))</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="fu">println</span>(<span class="st">"Average spacing calculated: </span><span class="sc">$</span>avg_spacing<span class="st">"</span>)</span>
<span id="cb6-10"><a href="#cb6-10"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, avg_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="st">"median"</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="fu">println</span>(<span class="st">"Calculating median spacing across all </span><span class="sc">$</span>channel_type<span class="st"> files and resampling."</span>)</span>
<span id="cb6-13"><a href="#cb6-13"></a>    all_spacings <span class="op">=</span> [img.spacing for channel <span class="kw">in</span> channels_data for img <span class="kw">in</span> channel]</span>
<span id="cb6-14"><a href="#cb6-14"></a>    median_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(<span class="fu">median</span>(s)) <span class="cf">for</span> s <span class="kw">in</span> all_spacings)</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="fu">println</span>(<span class="st">"Median spacing calculated: </span><span class="sc">$</span>median_spacing<span class="st">"</span>)</span>
<span id="cb6-16"><a href="#cb6-16"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, median_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="cn">false</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="fu">println</span>(<span class="st">"Skipping resampling of </span><span class="sc">$</span>channel_type<span class="st"> files."</span>)</span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="co"># No resampling will be applied, channels_data remains unchanged.</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> <code>Resample_to_spacing</code> uses interpolation that is not yet GPU-accelerated in this implementation, this step slow down the data preparation phase significantly.</p>
</section>
<section id="resizing-all-channels-files-to-average-or-target-size" class="level4">
<h4 class="anchored" data-anchor-id="resizing-all-channels-files-to-average-or-target-size">Resizing all channels files to average or target size âœ…</h4>
<p>To create a cohesive 5D tensor, all images in each channel are resized to a uniform shape, either the average size of all images or a specific target size. This resizing process uses <code>crop_or_pad</code>, ensuring that all images match the specified dimensions, making them suitable for model input.</p>
<details>
<summary>
crop_or_pad:
</summary>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1"></a><span class="cf">if</span> resample_size <span class="op">==</span> <span class="st">"avg"</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    sizes <span class="op">=</span> [<span class="fu">size</span>(img.voxel_data) for img <span class="kw">in</span> channels_data for img <span class="kw">in</span> img]  <span class="co"># Get sizes from all images</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    avg_dim <span class="op">=</span> <span class="fu">map</span>(mean, <span class="fu">zip</span>(sizes<span class="op">...</span>))</span>
<span id="cb7-4"><a href="#cb7-4"></a>    avg_dim <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Int</span>(<span class="fu">round</span>(d)) <span class="cf">for</span> d <span class="kw">in</span> avg_dim)</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="fu">println</span>(<span class="st">"Resizing all </span><span class="sc">$</span>channel_type<span class="st"> files to average dimension: </span><span class="sc">$</span>avg_dim<span class="st">"</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    channels_data <span class="op">=</span> [[<span class="fu">crop_or_pad</span>(img, avg_dim) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="cf">elseif</span> resample_size <span class="op">!=</span> <span class="st">"avg"</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    target_dim <span class="op">=</span> <span class="fu">Tuple</span>(resample_size)</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="fu">println</span>(<span class="st">"Resizing all </span><span class="sc">$</span>channel_type<span class="st"> files to target dimension: </span><span class="sc">$</span>target_dim<span class="st">"</span>)</span>
<span id="cb7-10"><a href="#cb7-10"></a>    channels_data <span class="op">=</span> [[<span class="fu">crop_or_pad</span>(img, target_dim) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
</section>
<section id="basic-post-processing-operations" class="level2">
<h2 class="anchored" data-anchor-id="basic-post-processing-operations">Basic Post-processing operations</h2>
<p>Post-processing operations involve algorithm <code>largest_connected_components</code>. It is achieved by label initialization and propagation in the segmented mask. <code>Initialize_labels_kernel</code> function assigns unique labels to different regions.</p>
<details>
<summary>
initialize_labels_kernel:
</summary>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">@kernel</span> <span class="kw">function</span> <span class="fu">initialize_labels_kernel</span>(mask, labels, width, height, depth)</span>
<span id="cb8-2"><a href="#cb8-2"></a>    idx <span class="op">=</span> <span class="pp">@index</span>(Global, Cartesian)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    i <span class="op">=</span> idx[<span class="fl">1</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>    j <span class="op">=</span> idx[<span class="fl">2</span>]</span>
<span id="cb8-5"><a href="#cb8-5"></a>    k <span class="op">=</span> idx[<span class="fl">3</span>]</span>
<span id="cb8-6"><a href="#cb8-6"></a>    </span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="cf">if</span> i <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> k <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> k <span class="op">&lt;=</span> depth</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">if</span> mask[i, j, k] <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>            labels[i, j, k] <span class="op">=</span> i <span class="op">+</span> (j <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> width <span class="op">+</span> (k <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> width <span class="op">*</span> height</span>
<span id="cb8-10"><a href="#cb8-10"></a>        <span class="cf">else</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>            labels[i, j, k] <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>        <span class="cf">end</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="cf">end</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
Propagate_labels_kernel iteratively updates the labels to maintain connected regions. propagate_labels_kernel:
<details>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">@kernel</span> <span class="kw">function</span> <span class="fu">propagate_labels_kernel</span>(mask, labels, width, height, depth)</span>
<span id="cb9-2"><a href="#cb9-2"></a>    idx<span class="op">=</span> <span class="pp">@index</span>(Global, Cartesian)</span>
<span id="cb9-3"><a href="#cb9-3"></a>    i <span class="op">=</span> idx[<span class="fl">1</span>]</span>
<span id="cb9-4"><a href="#cb9-4"></a>    j <span class="op">=</span> idx[<span class="fl">2</span>]</span>
<span id="cb9-5"><a href="#cb9-5"></a>    k <span class="op">=</span> idx[<span class="fl">3</span>]</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="cf">if</span> i <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> k <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> k <span class="op">&lt;=</span> depth</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">if</span> mask[i, j, k] <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>            current_label <span class="op">=</span> labels[i, j, k]</span>
<span id="cb9-10"><a href="#cb9-10"></a>            <span class="cf">for</span> di <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>                <span class="cf">for</span> dj <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>                    <span class="cf">for</span> dk <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>                        <span class="cf">if</span> di <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> dj <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> dk <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>                            <span class="cf">continue</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>                        <span class="cf">end</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>                        ni <span class="op">=</span> i <span class="op">+</span> di</span>
<span id="cb9-17"><a href="#cb9-17"></a>                        nj <span class="op">=</span> j <span class="op">+</span> dj</span>
<span id="cb9-18"><a href="#cb9-18"></a>                        nk <span class="op">=</span> k <span class="op">+</span> dk</span>
<span id="cb9-19"><a href="#cb9-19"></a>                        <span class="cf">if</span> ni <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> ni <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> nj <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> nj <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> nk <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> nk <span class="op">&lt;=</span> depth</span>
<span id="cb9-20"><a href="#cb9-20"></a>                            <span class="cf">if</span> mask[ni, nj, nk] <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> labels[ni, nj, nk] <span class="op">&lt;</span> current_label</span>
<span id="cb9-21"><a href="#cb9-21"></a>                                labels[i, j, k] <span class="op">=</span> labels[ni, nj, nk]</span>
<span id="cb9-22"><a href="#cb9-22"></a>                            <span class="cf">end</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>                        <span class="cf">end</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>                    <span class="cf">end</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>                <span class="cf">end</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>            <span class="cf">end</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>        <span class="cf">end</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>    <span class="cf">end</span></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>This process facilitates the identification of the largest connected components in 3D space, helping to isolate relevant medical structures, such as tumors, in the segmented mask. Giving the opportunity to determine how many such areas are to be returned.</p>
<details>
<summary>
largest_connected_components:
</summary>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">function</span> <span class="fu">largest_connected_components</span>(mask<span class="op">::</span><span class="dt">Array{Int32, 3}</span>, n_lcc<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a>    width, height, depth <span class="op">=</span> <span class="fu">size</span>(mask)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    mask_gpu <span class="op">=</span> <span class="fu">CuArray</span>(mask)</span>
<span id="cb10-4"><a href="#cb10-4"></a>    labels_gpu <span class="op">=</span> CUDA.<span class="fu">fill</span>(<span class="fl">0</span>, <span class="fu">size</span>(mask))</span>
<span id="cb10-5"><a href="#cb10-5"></a>    dev <span class="op">=</span> <span class="fu">get_backend</span>(labels_gpu)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    ndrange <span class="op">=</span> (width, height, depth)</span>
<span id="cb10-7"><a href="#cb10-7"></a>    workgroupsize <span class="op">=</span> (<span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span>)</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="co"># Initialize labels</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="fu">initialize_labels_kernel</span>(dev)(mask_gpu, labels_gpu, width, height, depth, ndrange <span class="op">=</span> ndrange)</span>
<span id="cb10-11"><a href="#cb10-11"></a>    CUDA.<span class="fu">synchronize</span>()</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="co"># Propagate labels iteratively</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span> </span>
<span id="cb10-15"><a href="#cb10-15"></a>        <span class="fu">propagate_labels_kernel</span>(dev, workgroupsize)(mask_gpu, labels_gpu, width, height, depth, ndrange <span class="op">=</span> ndrange)</span>
<span id="cb10-16"><a href="#cb10-16"></a>        CUDA.<span class="fu">synchronize</span>()</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="cf">end</span></span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="co"># Download labels back to CPU</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    labels_cpu <span class="op">=</span> <span class="fu">Array</span>(labels_gpu)</span>
<span id="cb10-21"><a href="#cb10-21"></a>    </span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="co"># Find all unique labels and their sizes</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>    unique_labels <span class="op">=</span> <span class="fu">unique</span>(labels_cpu)</span>
<span id="cb10-24"><a href="#cb10-24"></a>    label_sizes <span class="op">=</span> [(label, <span class="fu">count</span>(labels_cpu <span class="op">.==</span> label)) for label <span class="kw">in</span> unique_labels if label <span class="op">!=</span> <span class="fl">0</span>]</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="co"># Sort labels by size and get the top n_lcc</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="fu">sort!</span>(label_sizes, by <span class="op">=</span> x <span class="op">-&gt;</span> x[<span class="fl">2</span>], rev <span class="op">=</span> <span class="cn">true</span>)</span>
<span id="cb10-28"><a href="#cb10-28"></a>    top_labels <span class="op">=</span> label_sizes[<span class="fl">1</span><span class="op">:</span><span class="fu">min</span>(n_lcc, <span class="fu">length</span>(label_sizes))]</span>
<span id="cb10-29"><a href="#cb10-29"></a></span>
<span id="cb10-30"><a href="#cb10-30"></a>    <span class="co"># Create a mask for each of the top n_lcc components</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    components <span class="op">=</span> [labels_cpu <span class="op">.==</span> label[<span class="fl">1</span>] for label <span class="kw">in</span> top_labels]</span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="cf">return</span> components</span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="structured-configuration-of-all-hyperparameters" class="level2">
<h2 class="anchored" data-anchor-id="structured-configuration-of-all-hyperparameters">Structured configuration of all hyperparameters ğŸ†™</h2>
<p>Hyperparameters for the entire pipeline are stored in a JSON configuration file, enabling straightforward adjustments for experimentation (just swap values, save and resume the study). This structured setup allows easy modification of key parameters, such as data set preparation, training settings, data augmentation, and resampling options.</p>
<details>
<summary>
Example configuration:
</summary>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource json number-lines code-with-copy"><code class="sourceCode json"><span id="cb11-1"><a href="#cb11-1"></a><span class="fu">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="dt">"model"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>        <span class="dt">"patience"</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="dt">"early_stopping_metric"</span><span class="fu">:</span> <span class="st">"val_loss"</span><span class="fu">,</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="dt">"optimizer_name"</span><span class="fu">:</span> <span class="st">"Adam"</span><span class="fu">,</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="dt">"loss_function_name"</span><span class="fu">:</span> <span class="st">"l1"</span><span class="fu">,</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="dt">"early_stopping"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="dt">"early_stopping_min_delta"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.01</span><span class="fu">,</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="dt">"optimizer_args"</span><span class="fu">:</span> <span class="st">"lr=0.001"</span><span class="fu">,</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>        <span class="dt">"num_epochs"</span><span class="fu">:</span> <span class="dv">10</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="fu">},</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="dt">"data"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="dt">"batch_complete"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>        <span class="dt">"resample_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">200</span><span class="ot">,</span><span class="dv">101</span><span class="ot">,</span><span class="dv">49</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>        <span class="dt">"resample_to_target"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>        <span class="dt">"resample_to_spacing"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="dt">"batch_size"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>        <span class="dt">"standardization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>        <span class="dt">"target_spacing"</span><span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span></span>
<span id="cb11-20"><a href="#cb11-20"></a>        <span class="dt">"channel_size"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb11-21"><a href="#cb11-21"></a>        <span class="dt">"normalization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>        <span class="dt">"has_mask"</span><span class="fu">:</span> <span class="kw">true</span></span>
<span id="cb11-23"><a href="#cb11-23"></a>    <span class="fu">},</span></span>
<span id="cb11-24"><a href="#cb11-24"></a>    <span class="dt">"augmentation"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-25"><a href="#cb11-25"></a>        <span class="dt">"augmentations"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-26"><a href="#cb11-26"></a>            <span class="dt">"Brightness transform"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>                <span class="dt">"mode"</span><span class="fu">:</span> <span class="st">"additive"</span><span class="fu">,</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>                <span class="dt">"value"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>            <span class="fu">}</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>        <span class="fu">},</span></span>
<span id="cb11-31"><a href="#cb11-31"></a>        <span class="dt">"p_rand"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">5</span><span class="fu">,</span></span>
<span id="cb11-32"><a href="#cb11-32"></a>        <span class="dt">"processing_unit"</span><span class="fu">:</span> <span class="st">"GPU"</span><span class="fu">,</span></span>
<span id="cb11-33"><a href="#cb11-33"></a>        <span class="dt">"order"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb11-34"><a href="#cb11-34"></a>            <span class="st">"Brightness transform"</span></span>
<span id="cb11-35"><a href="#cb11-35"></a>        <span class="ot">]</span></span>
<span id="cb11-36"><a href="#cb11-36"></a>    <span class="fu">},</span></span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="dt">"learning"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-38"><a href="#cb11-38"></a>        <span class="dt">"Train_Val_Test_JSON"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-39"><a href="#cb11-39"></a>        <span class="dt">"largest_connected_component"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>        <span class="dt">"n_lcc"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb11-41"><a href="#cb11-41"></a>        <span class="dt">"n_folds"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb11-42"><a href="#cb11-42"></a>        <span class="dt">"invertible_augmentations"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-43"><a href="#cb11-43"></a>        <span class="dt">"n_invertible"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb11-44"><a href="#cb11-44"></a>        </span>
<span id="cb11-45"><a href="#cb11-45"></a>        <span class="dt">"class_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-46"><a href="#cb11-46"></a>        <span class="dt">"additional_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-47"><a href="#cb11-47"></a>        <span class="dt">"patch_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-48"><a href="#cb11-48"></a>        <span class="dt">"metric"</span><span class="fu">:</span> <span class="st">"dice"</span><span class="fu">,</span></span>
<span id="cb11-49"><a href="#cb11-49"></a>        <span class="dt">"n_cross_val"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-50"><a href="#cb11-50"></a>        <span class="dt">"patch_probabilistic_oversampling"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-51"><a href="#cb11-51"></a>        <span class="dt">"oversampling_probability"</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span></span>
<span id="cb11-52"><a href="#cb11-52"></a>        <span class="dt">"test_train_validation"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb11-53"><a href="#cb11-53"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">6</span><span class="ot">,</span></span>
<span id="cb11-54"><a href="#cb11-54"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span><span class="ot">,</span></span>
<span id="cb11-55"><a href="#cb11-55"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb11-56"><a href="#cb11-56"></a>        <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-57"><a href="#cb11-57"></a>        <span class="dt">"shuffle"</span><span class="fu">:</span> <span class="kw">false</span></span>
<span id="cb11-58"><a href="#cb11-58"></a>    <span class="fu">}</span></span>
<span id="cb11-59"><a href="#cb11-59"></a><span class="fu">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comments:<br> The current configuration is loaded as a dictionary, which simplifies access and modification. This setup presents a strong foundation for integrating automated search algorithms for hyperparameter tuning, enabling more efficient model optimization.<br> The configuration structure could be re-organized and re-named to improve readability, making it easier for users to locate and adjust specific parameters.</p>
</section>
<section id="visualization-of-algorithm-outputs" class="level2">
<h2 class="anchored" data-anchor-id="visualization-of-algorithm-outputs">Visualization of algorithm outputs âš ï¸</h2>
<p>This module provides basic visualization functionality by saving output masks and images first to MedImage format and then to Nifti format. The <code>create_nii_from_medimage</code> function from MedImage.jl generates Nifti files, which can be loaded into MedEye3D for 3D visualization.</p>
<p>Comments:<br> Integrating this visualization module more fully with the pipeline could eliminate unnecessary steps. By automatically loading output masks and images in as raw data into MedEye3D for 3D visualization and supporting a more efficient end-to-end workflow.</p>
</section>
<section id="k-fold-cross-validation-functionality" class="level2">
<h2 class="anchored" data-anchor-id="k-fold-cross-validation-functionality">K-fold cross-validation functionality âœ…</h2>
<p>K-fold cross-validation is implemented to evaluate model performance more robustly. The data is split into multiple folds, with each fold serving as a validation set once, while the others form the training set. This functionality provides a better assessment of model performance across different subsets of the data.</p>
<details>
<summary>
K-fold cross-validation functionality:
</summary>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">...</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  tstate <span class="op">=</span> <span class="fu">initialize_train_state</span>(rng, model, optimizer)</span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="cf">if</span> config[<span class="st">"learning"</span>][<span class="st">"n_cross_val"</span>]</span>
<span id="cb12-4"><a href="#cb12-4"></a>      n_folds <span class="op">=</span> config[<span class="st">"learning"</span>][<span class="st">"n_folds"</span>]</span>
<span id="cb12-5"><a href="#cb12-5"></a>      all_tstate <span class="op">=</span> []</span>
<span id="cb12-6"><a href="#cb12-6"></a>      combined_indices <span class="op">=</span> [indices_dict[<span class="st">"train"</span>]; indices_dict[<span class="st">"validation"</span>]]</span>
<span id="cb12-7"><a href="#cb12-7"></a>      shuffled_indices <span class="op">=</span> <span class="fu">shuffle</span>(rng, combined_indices)</span>
<span id="cb12-8"><a href="#cb12-8"></a>      <span class="cf">for</span> fold <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n_folds</span>
<span id="cb12-9"><a href="#cb12-9"></a>          <span class="fu">println</span>(<span class="st">"Starting fold </span><span class="sc">$</span>fold<span class="st">/</span><span class="sc">$</span>n_folds<span class="st">"</span>)</span>
<span id="cb12-10"><a href="#cb12-10"></a>          train_groups, validation_groups <span class="op">=</span> <span class="fu">k_fold_split</span>(combined_indices, n_folds, fold, rng)</span>
<span id="cb12-11"><a href="#cb12-11"></a>          </span>
<span id="cb12-12"><a href="#cb12-12"></a>          tstate <span class="op">=</span> <span class="fu">initialize_train_state</span>(rng, model, optimizer)</span>
<span id="cb12-13"><a href="#cb12-13"></a>          final_tstate <span class="op">=</span> <span class="fu">epoch_loop</span>(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span>
<span id="cb12-14"><a href="#cb12-14"></a>          </span>
<span id="cb12-15"><a href="#cb12-15"></a>          <span class="fu">push!</span>(all_tstate, final_tstate)</span>
<span id="cb12-16"><a href="#cb12-16"></a>      <span class="cf">end</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>  <span class="cf">else</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>      final_tstate <span class="op">=</span> <span class="fu">epoch_loop</span>(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span>
<span id="cb12-19"><a href="#cb12-19"></a>  <span class="cf">end</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>  <span class="cf">return</span> final_tstate</span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="op">...</span>  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>The <code>k_fold_split</code> function organizes the indices for each fold, ensuring comprehensive coverage of the dataset during training.</p>
<details>
<summary>
k_fold_split
</summary>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">function</span> <span class="fu">k_fold_split</span>(data, n_folds, current_fold)</span>
<span id="cb13-2"><a href="#cb13-2"></a>    fold_size <span class="op">=</span> <span class="fu">length</span>(data) <span class="op">Ã·</span> n_folds</span>
<span id="cb13-3"><a href="#cb13-3"></a>    validation_start <span class="op">=</span> (current_fold <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> fold_size <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    validation_end <span class="op">=</span> validation_start <span class="op">+</span> fold_size <span class="op">-</span> <span class="fl">1</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    validation_indices <span class="op">=</span> data[validation_start<span class="op">:</span>validation_end]</span>
<span id="cb13-6"><a href="#cb13-6"></a>    train_indices <span class="op">=</span> [data[<span class="fl">1</span><span class="op">:</span>validation_start<span class="op">-</span><span class="fl">1</span>]; data[validation_end<span class="op">+</span><span class="fl">1</span><span class="op">:</span><span class="kw">end</span>]]</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="cf">return</span> train_indices, validation_indices</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
</section>
<section id="conclusions-and-future-development" class="level1">
<h1>Conclusions and Future Development</h1>
<p>I have successfully established a foundation for a medical imaging pipeline, addressing significant challenges in data handling, model training, and augmentation integration. The integration of dataset-wide functions has significantly enhanced the reproducibility and handling batched data with GPU supporrt enables scalability of experiments, making it easier for researchers and practitioners to produce better results.</p>
</section>
<section id="future-development" class="level1">
<h1>Future Development</h1>
<p>As we look to the future, there are several areas where MedPipe3D can be expanded and improved to better serve the medical AI community. These include:</p>
<section id="necessary-enhancements" class="level2">
<h2 class="anchored" data-anchor-id="necessary-enhancements">Necessary Enhancements</h2>
<p>Comprehensive Logging: Develop detailed logging mechanisms that capture a wide range of events, including system statuses, model performance metrics, and user activities, to facilitate debugging and system optimization. This is currently executed as a simple println function.</p>
<!--
   - TODO: Could you link to TensorBoard?
   -->
<p>TensorBoard Integration: Implement an interface for TensorBoard to allow users to visualize training dynamics in real-time, providing insights into model behavior and performance trends.</p>
<p>Error and Warning Logs: Introduce advanced error and warning logging capabilities to alert users of potential issues before they affect the pipelineâ€™s performance, ensuring smoother operations and maintenance.</p>
<p>Automated Visualization: Integrate MedEye3D directly into MedPipe3D to enable automated visualization of outputs, such as segmentation masks or other relevant medical imaging features. This feature would provide users with real time visual feedback on model performance and data quality. Code-Level Documentation: Due to needed changes in the fundamental structure of pipeline in the final phase of the project, it is necessary to reevaluate all documentation.</p>
<!--
   - TODO: Could you add a link here to the website?
   -->
<p>Official JuliaHealth Documentation: Extend the documentation efforts to include official entries on juliahealth.org, providing a centralized and authoritative resource for users seeking to learn more about MedPipe3D and its capabilities with examples shown</p>
</section>
<section id="potential-enhancements" class="level2">
<h2 class="anchored" data-anchor-id="potential-enhancements">Potential Enhancements</h2>
<p>GPU support for interpolation will allow to significantly accelerate such functions as: Scale transform, Simulate, Low-resolution transform, Elastic deformation transform, Resampling spacing</p>
<p>Add more reversible augmentations to test time</p>
<p>Calculating the average of the edges of the picture: hecking the type of photo and calculating more correctly on this basis</p>
<p>Elastic deformation transform with simulation of different tissue elasticities</p>
</section>
</section>
<section id="acknowledgments" class="level1">
<h1>Acknowledgments ğŸ™‡â€â™‚ï¸</h1>
<p>I would like to express my deepest gratitude to my mentor Dr.&nbsp;<a href="https://www.linkedin.com/in/jakub-mitura-7b2013151/">Jakub Mitura</a> for his invaluable guidance and support throughout this project. His expertise and encouragement were instrumental in overcoming challenges and achieving project milestones.</p>


<!-- -->

</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{zubik2024,
  author = {Zubik, Jan},
  title = {GSoC â€™24: {Adding} Dataset-Wide Functions and Integrations of
    Augmentations},
  date = {2024-11-03},
  url = {https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-zubik2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Zubik, Jan. 2024. <span>â€œGSoC â€™24: Adding Dataset-Wide Functions and
Integrations of Augmentations.â€</span> November 3, 2024. <a href="https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html">https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/juliahealth\.org\/JuliaHealthBlog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="JuliaHealth/JuliaHealthBlog" issue-term="title" theme="github-dark" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb14" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">---</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="an">title:</span><span class="co"> "GSoC '24: Adding dataset-wide functions and integrations of augmentations"</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="an">description:</span><span class="co"> "MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations."</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="an">author:</span><span class="co"> "Jan Zubik"</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="an">date:</span><span class="co"> "11/03/2024"</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="an">categories:</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">  - gsoc</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">  - AI/ML</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="co">  - imaging</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="co">  - gpu</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="co">  - analysis</span></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="co">---</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="fu"># ğŸ“ğŸ©»ğŸ“ğŸ“‰ â¡ï¸ ğŸ—ƒï¸ğŸ“šâ™»ï¸ğŸ§‘â€ğŸ« â¡ï¸ ğŸ¤–ğŸ‘ï¸ğŸ“ˆ â¡ï¸ â¤ï¸â€ğŸ©¹  </span></span>
<span id="cb14-17"><a href="#cb14-17"></a>*These emoticons may resemble **hieroglyphics**, but very soon you will realize that they **mean more than 1000s** of lines of code.*</span>
<span id="cb14-18"><a href="#cb14-18"></a></span>
<span id="cb14-19"><a href="#cb14-19"></a>&lt;details&gt;</span>
<span id="cb14-20"><a href="#cb14-20"></a>  &lt;summary&gt;Description of the emojis used in the title&lt;/summary&gt;</span>
<span id="cb14-21"><a href="#cb14-21"></a>  &lt;ul&gt;</span>
<span id="cb14-22"><a href="#cb14-22"></a>    &lt;li&gt;ğŸ“ **Action Plan**: A clear, structured plan that guides the setup and configuration of the MedPipe3D pipeline.&lt;/li&gt;</span>
<span id="cb14-23"><a href="#cb14-23"></a>    &lt;li&gt;ğŸ©» **3D Medical Images**: Medical imaging data, such as MRI scans, to be processed and analyzed by the AI model.&lt;/li&gt;</span>
<span id="cb14-24"><a href="#cb14-24"></a>    &lt;li&gt;ğŸ“ **AI Model**: The initial AI model or architecture that will be trained and refined within the pipeline.&lt;/li&gt;</span>
<span id="cb14-25"><a href="#cb14-25"></a>    &lt;li&gt;ğŸ“‰ **Loss Function**: A function that measures the modelâ€™s performance during training, guiding the optimization process.&lt;/li&gt;    </span>
<span id="cb14-26"><a href="#cb14-26"></a>    &lt;li&gt;ğŸ—ƒï¸ **Data Loading**: Loading raw data into the pipeline for further processing.&lt;/li&gt;</span>
<span id="cb14-27"><a href="#cb14-27"></a>    &lt;li&gt;ğŸ“š **Data Splitting**: Dividing data into training, validation, and test sets to prepare for model training and evaluation.&lt;/li&gt;</span>
<span id="cb14-28"><a href="#cb14-28"></a>    &lt;li&gt;â™»ï¸ **Data Augmentation**: Increasing data variability through augmentation, enhancing the model's generalization capabilities.&lt;/li&gt;</span>
<span id="cb14-29"><a href="#cb14-29"></a>    &lt;li&gt;ğŸ§‘â€ğŸ« **AI Training**: Using the processed data to train the AI model, improving its accuracy and performance.&lt;/li&gt;</span>
<span id="cb14-30"><a href="#cb14-30"></a>    &lt;li&gt;ğŸ¤– **Model**: The trained AI model that can perform tasks such as segmentation on medical images.&lt;/li&gt;</span>
<span id="cb14-31"><a href="#cb14-31"></a>    &lt;li&gt;ğŸ‘ï¸ **Data for Visualization**: Output data, such as masks and segmentations, which can be interpreted directly on medical scans.&lt;/li&gt;</span>
<span id="cb14-32"><a href="#cb14-32"></a>    &lt;li&gt;ğŸ“ˆ **Performance Logs**: Logs and metrics documenting the AI's performance, ready for further analysis in tools like MedEval3D and MedEye3D.&lt;/li&gt;</span>
<span id="cb14-33"><a href="#cb14-33"></a>    &lt;li&gt;â¤ï¸â€ğŸ©¹ **Purpose of MedPipe3D**: The goal is to create AI tools that assist healthcare professionals in making faster, more accurate decisions, ultimately helping save lives.&lt;/li&gt;</span>
<span id="cb14-34"><a href="#cb14-34"></a>  &lt;/ul&gt;</span>
<span id="cb14-35"><a href="#cb14-35"></a></span>
<span id="cb14-36"><a href="#cb14-36"></a>&lt;/details&gt;</span>
<span id="cb14-37"><a href="#cb14-37"></a></span>
<span id="cb14-38"><a href="#cb14-38"></a>&lt;hr&gt;</span>
<span id="cb14-39"><a href="#cb14-39"></a>In this post, I'd like to summarize what I did this summer and everything I learned along the way, rebuilding MedPipe3D medical imaging pipeline. I will not start typically, but so that anyone even a novice can visualize what this project has achieved, while the latter part is intended for more experienced readers. It will be easiest to divide it into 4 steps separated by â¡ï¸ in the title above. Each emoji stands for a different piece of pipeliner and will be described below.</span>
<span id="cb14-40"><a href="#cb14-40"></a></span>
<span id="cb14-41"><a href="#cb14-41"></a>ğŸ“ğŸ©»ğŸ“ğŸ“‰ **What we need from the user**</span>
<span id="cb14-42"><a href="#cb14-42"></a></span>
<span id="cb14-43"><a href="#cb14-43"></a>MedPipe3D requires four essential inputs from user to get started: a clear action plan ğŸ“, 3D medical images like MRI scans ğŸ©», an AI model ğŸ“, and a loss function ğŸ“‰.</span>
<span id="cb14-44"><a href="#cb14-44"></a></span>
<span id="cb14-45"><a href="#cb14-45"></a>ğŸ—ƒï¸ğŸ“šâ™»ï¸ğŸ§‘â€ğŸ« **The Pipeline essential AI manufacturing line**</span>
<span id="cb14-46"><a href="#cb14-46"></a></span>
<span id="cb14-47"><a href="#cb14-47"></a>Following the plan ğŸ“, MedPipe3D loads data, pre-processes and organizes it ğŸ—ƒï¸. Allowing data to be easily split ğŸ“š, efficiently augmented â™»ï¸ in many ways for learning AI ğŸ§‘â€ğŸ« model effectively. In the end performing testing and post processing for better determination of AI skills.  </span>
<span id="cb14-48"><a href="#cb14-48"></a>It's designed to transform raw medical data into a format that your AI can learn from, segmenting meaningful patterns and structures.</span>
<span id="cb14-49"><a href="#cb14-49"></a></span>
<span id="cb14-50"><a href="#cb14-50"></a>ğŸ¤–ğŸ‘ï¸ğŸ“ˆ **Results and Insights**</span>
<span id="cb14-51"><a href="#cb14-51"></a></span>
<span id="cb14-52"><a href="#cb14-52"></a>MedPipe3D is a tool for researchers and for that it cannot do without analysis, testing and evaluation. The result of the pipeline is a model ğŸ¤– as well as data ğŸ‘ï¸ and logs ğŸ“ˆ needed in MedEval3D that are ready for visualization and further analysis with MedEye3D. In a nutshell, it makes visualizing results easy-showing, tumor locations or other medical features directly as masks on the scans.</span>
<span id="cb14-53"><a href="#cb14-53"></a></span>
<span id="cb14-54"><a href="#cb14-54"></a>â¤ï¸â€ğŸ©¹ **Purpose-Driven Technology**</span>
<span id="cb14-55"><a href="#cb14-55"></a></span>
<span id="cb14-56"><a href="#cb14-56"></a>MedPipe3D's mission goes beyond technology. It's about providing the tools to create AIs that support healthcare professionals in making faster, more accurate decisions, with the ultimate goal of saving lives.</span>
<span id="cb14-57"><a href="#cb14-57"></a></span>
<span id="cb14-58"><a href="#cb14-58"></a>This four-part journey captures the heart of MedPipe3D toolkit for advancing medical AI, from raw data to life-saving insight.</span>
<span id="cb14-59"><a href="#cb14-59"></a></span>
<span id="cb14-60"><a href="#cb14-60"></a><span class="fu">## Introduction</span></span>
<span id="cb14-61"><a href="#cb14-61"></a></span>
<span id="cb14-62"><a href="#cb14-62"></a>**MedPipe3D** is a framework created from hundreds of hours over summer vacation, thousands of lines of code, hundreds mistakes and most importantly the guidance of my mentor and author of all of these libraries Dr. <span class="co">[</span><span class="ot">Jakub Mitura</span><span class="co">](https://www.linkedin.com/in/jakub-mitura-7b2013151/)</span>.</span>
<span id="cb14-63"><a href="#cb14-63"></a>At its core, MedPipe3D combines sophisticated data handling from **MedImage** thanks to the hard work of [Divyansh Goyal](https://www.linkedin.com/in/divyansh-goyal-34654b200/). Newly developed pipeline for model training, validation and testing with existing **MedEval3D**, and result visualization with **MedEye3D**.</span>
<span id="cb14-64"><a href="#cb14-64"></a>Unfortunately, not all the project's goals have been fully achieved, and thereby there is one section â¡ï¸ too many. Hopefully not for long. My name is <span class="co">[</span><span class="ot">Jan Zubik</span><span class="co">](https://www.linkedin.com/in/janzubik/)</span>, and I wrote this entire library from scratch, which is currently my most complex project.</span>
<span id="cb14-65"><a href="#cb14-65"></a></span>
<span id="cb14-66"><a href="#cb14-66"></a>If you are a data scientist, programmer, code enthusiast, I invite you to read the next section where I go into detail and present **version 1** of this tool in detail.</span>
<span id="cb14-67"><a href="#cb14-67"></a></span>
<span id="cb14-68"><a href="#cb14-68"></a>I'm a 3rd-year student of BSc in Data Science and Machine Learning, I know that many things can be done better, expanded, debugged and optimized. Now it just works, **but don't hesitate to write to me personally** on <span class="co">[</span><span class="ot">LinkedIn</span><span class="co">](https://www.linkedin.com/in/janzubik/)</span>, <span class="co">[</span><span class="ot">Julia's Slack</span><span class="co">](https://julialang.slack.com/team/U06L685B6TD)</span> or <span class="co">[</span><span class="ot">GitHub</span><span class="co">](https://github.com/JanZubik)</span>!</span>
<span id="cb14-69"><a href="#cb14-69"></a>With your comments, direct critique **you will help me** to be a better programmer and one day MedPipe3D will contribute in a tiny way to save someone's life!</span>
<span id="cb14-70"><a href="#cb14-70"></a></span>
<span id="cb14-71"><a href="#cb14-71"></a>Exact work from the Google Summer of Code project you will find in <span class="co">[</span><span class="ot">GitHub the repository.</span><span class="co">](https://github.com/JuliaHealth/MedPipe3D.jl/tree/GSoC-'24-MedPipe3D)</span></span>
<span id="cb14-72"><a href="#cb14-72"></a></span>
<span id="cb14-73"><a href="#cb14-73"></a></span>
<span id="cb14-74"><a href="#cb14-74"></a><span class="fu"># Project Goals</span></span>
<span id="cb14-75"><a href="#cb14-75"></a></span>
<span id="cb14-76"><a href="#cb14-76"></a>Primary goal was to develop MedPipe3D and enhance MedImage, a Julia packages designed to streamline the process of GPU-accelerated medical image segmentation. The project aimed to merge existing librariesâ€”MedEye3D, MedEval3D, and MedImageâ€”into a cohesive pipeline that facilitates advanced data handling, preprocessing, augmentation, model training, validation, testing with post-procesing and visualization for medical imaging applications.</span>
<span id="cb14-77"><a href="#cb14-77"></a></span>
<span id="cb14-78"><a href="#cb14-78"></a></span>
<span id="cb14-79"><a href="#cb14-79"></a></span>
<span id="cb14-80"><a href="#cb14-80"></a><span class="fu"># Tasks</span></span>
<span id="cb14-81"><a href="#cb14-81"></a></span>
<span id="cb14-82"><a href="#cb14-82"></a><span class="ss">- </span>ğŸ†™ - Fully finished, with great potential for further development</span>
<span id="cb14-83"><a href="#cb14-83"></a><span class="ss">- </span>âœ… - Fully completed</span>
<span id="cb14-84"><a href="#cb14-84"></a><span class="ss">- </span>âš ï¸ - Partially uncompleted</span>
<span id="cb14-85"><a href="#cb14-85"></a><span class="ss">- </span>âŒ - Unreached</span>
<span id="cb14-86"><a href="#cb14-86"></a></span>
<span id="cb14-87"><a href="#cb14-87"></a>Full list of all major parts and minor tasks (all tasks set up in original GSOC plan were complete in at least minimum level, many additional improvments above minimum were implemented)</span>
<span id="cb14-88"><a href="#cb14-88"></a>&lt;details&gt;</span>
<span id="cb14-89"><a href="#cb14-89"></a></span>
<span id="cb14-90"><a href="#cb14-90"></a><span class="ss">1. </span>**Helpful functions to support the MedImage format âœ…**</span>
<span id="cb14-91"><a href="#cb14-91"></a><span class="ss">  - </span>Debugging rotations âœ…</span>
<span id="cb14-92"><a href="#cb14-92"></a><span class="ss">  - </span>Crop MedImage or 3D array âœ…</span>
<span id="cb14-93"><a href="#cb14-93"></a><span class="ss">  - </span>Pad MedImage or 3D array âœ…</span>
<span id="cb14-94"><a href="#cb14-94"></a><span class="ss">  - </span>Pad with edge values âœ…</span>
<span id="cb14-95"><a href="#cb14-95"></a><span class="ss">  - </span>Calculating the average of the edges of the picture ğŸ†™</span>
<span id="cb14-96"><a href="#cb14-96"></a></span>
<span id="cb14-97"><a href="#cb14-97"></a><span class="ss">2. </span>**Integrate Augmentations for Medical Data âœ…**</span>
<span id="cb14-98"><a href="#cb14-98"></a><span class="ss">  - </span>Brightness transform âœ…</span>
<span id="cb14-99"><a href="#cb14-99"></a><span class="ss">  - </span>Contrast augmentation transform âœ…</span>
<span id="cb14-100"><a href="#cb14-100"></a><span class="ss">  - </span>Gamma Transform âœ…</span>
<span id="cb14-101"><a href="#cb14-101"></a><span class="ss">  - </span>Gaussian noise transform âœ…</span>
<span id="cb14-102"><a href="#cb14-102"></a><span class="ss">  - </span>Rician noise transform âœ…</span>
<span id="cb14-103"><a href="#cb14-103"></a><span class="ss">  - </span>Mirror transform âœ…</span>
<span id="cb14-104"><a href="#cb14-104"></a><span class="ss">  - </span>Scale transform ğŸ†™</span>
<span id="cb14-105"><a href="#cb14-105"></a><span class="ss">  - </span>Gaussian blur transform âœ…</span>
<span id="cb14-106"><a href="#cb14-106"></a><span class="ss">  - </span>Simulate low-resolution transform ğŸ†™</span>
<span id="cb14-107"><a href="#cb14-107"></a><span class="ss">  - </span>Elastic deformation transform ğŸ†™</span>
<span id="cb14-108"><a href="#cb14-108"></a></span>
<span id="cb14-109"><a href="#cb14-109"></a><span class="ss">3. </span>**Develop a Pipeline âš ï¸**</span>
<span id="cb14-110"><a href="#cb14-110"></a><span class="ss">  - </span>Structured configuration of all hyperparameters ğŸ†™</span>
<span id="cb14-111"><a href="#cb14-111"></a><span class="ss">   - </span>Interactive creation of configuration âœ…</span>
<span id="cb14-112"><a href="#cb14-112"></a><span class="ss">   - </span>Creating a structured configuration of hyperparameters in JSON ğŸ†™</span>
<span id="cb14-113"><a href="#cb14-113"></a><span class="ss">  - </span>Loading data into HDF5 âœ…</span>
<span id="cb14-114"><a href="#cb14-114"></a><span class="ss">    - </span>Cropping and padding to real coordinates of the main picture âœ…</span>
<span id="cb14-115"><a href="#cb14-115"></a><span class="ss">    - </span>Calculate Median and Mean Spacing with resampling ğŸ†™</span>
<span id="cb14-116"><a href="#cb14-116"></a><span class="ss">    - </span>Cropping and padding to specific or average dimensions âœ…</span>
<span id="cb14-117"><a href="#cb14-117"></a><span class="ss">    - </span>Standardization and normalization âœ…</span>
<span id="cb14-118"><a href="#cb14-118"></a><span class="ss">  - </span>Managing indexes groups (channels) for batche requirements in HDF5 âœ…</span>
<span id="cb14-119"><a href="#cb14-119"></a><span class="ss">    - </span>Divide in to train, validation, test specified as % âœ…</span>
<span id="cb14-120"><a href="#cb14-120"></a><span class="ss">    - </span>Divide with a specific division specified in JSON âœ…</span>
<span id="cb14-121"><a href="#cb14-121"></a><span class="ss">    - </span>Equal distribution when there are multiple classes âœ…</span>
<span id="cb14-122"><a href="#cb14-122"></a><span class="ss">  - </span>Extracting data and creating 5-dimensional tensors for batched learning âœ…</span>
<span id="cb14-123"><a href="#cb14-123"></a><span class="ss">    - </span>Hole images data loading âœ…</span>
<span id="cb14-124"><a href="#cb14-124"></a><span class="ss">    - </span>Patch-based data loading with probabilistic oversampling âœ…</span>
<span id="cb14-125"><a href="#cb14-125"></a><span class="ss">  - </span>Obtaining the necessary elements for learning âœ…</span>
<span id="cb14-126"><a href="#cb14-126"></a><span class="ss">    - </span>Get optimizer, loss function, performance metrics âœ…</span>
<span id="cb14-127"><a href="#cb14-127"></a><span class="ss">  - </span>Apply augmentations âœ…</span>
<span id="cb14-128"><a href="#cb14-128"></a><span class="ss">  - </span>Train âœ…</span>
<span id="cb14-129"><a href="#cb14-129"></a><span class="ss">    - </span>Initializing model âœ…</span>
<span id="cb14-130"><a href="#cb14-130"></a><span class="ss">    - </span>The learning epoch âœ…</span>
<span id="cb14-131"><a href="#cb14-131"></a><span class="ss">    - </span>Epoch with early stopping funcionality âœ…</span>
<span id="cb14-132"><a href="#cb14-132"></a><span class="ss">  - </span>Infering âœ…</span>
<span id="cb14-133"><a href="#cb14-133"></a><span class="ss">  - </span>Validation âœ…</span>
<span id="cb14-134"><a href="#cb14-134"></a><span class="ss">    - </span>Evaluate metric âœ…</span>
<span id="cb14-135"><a href="#cb14-135"></a><span class="ss">    - </span>Evaluate validation loss âœ…</span>
<span id="cb14-136"><a href="#cb14-136"></a><span class="ss">    - </span>Validation with largest connected componentâœ…</span>
<span id="cb14-137"><a href="#cb14-137"></a><span class="ss">  - </span>Testing âœ…</span>
<span id="cb14-138"><a href="#cb14-138"></a><span class="ss">    - </span>Evaluate test set âœ…</span>
<span id="cb14-139"><a href="#cb14-139"></a><span class="ss">    - </span>Invertible augmentations evaluation âœ…</span>
<span id="cb14-140"><a href="#cb14-140"></a><span class="ss">    - </span>Patch-based invertible augmentations evaluation âœ…</span>
<span id="cb14-141"><a href="#cb14-141"></a><span class="ss">  - </span>Logging âš ï¸</span>
<span id="cb14-142"><a href="#cb14-142"></a><span class="ss">    - </span>Returning the necessary results âš ï¸</span>
<span id="cb14-143"><a href="#cb14-143"></a><span class="ss">    - </span>Logging connection to tensorboard âŒ</span>
<span id="cb14-144"><a href="#cb14-144"></a><span class="ss">    - </span>Logging errors and warnings âŒ</span>
<span id="cb14-145"><a href="#cb14-145"></a><span class="ss">  - </span>Visualization âš ï¸</span>
<span id="cb14-146"><a href="#cb14-146"></a><span class="ss">    - </span>Returning data in Nifti format âœ…</span>
<span id="cb14-147"><a href="#cb14-147"></a><span class="ss">    - </span>Automated visualization in MedEye3D âŒ</span>
<span id="cb14-148"><a href="#cb14-148"></a></span>
<span id="cb14-149"><a href="#cb14-149"></a><span class="ss">4. </span>**Optimize Performance with GPU Acceleration**</span>
<span id="cb14-150"><a href="#cb14-150"></a><span class="ss">   - </span>Augmentations âœ…</span>
<span id="cb14-151"><a href="#cb14-151"></a><span class="ss">   - </span>Learning, Validation, Testing âœ…</span>
<span id="cb14-152"><a href="#cb14-152"></a><span class="ss">   - </span>Largest connected component âœ…</span>
<span id="cb14-153"><a href="#cb14-153"></a></span>
<span id="cb14-154"><a href="#cb14-154"></a><span class="ss">5. </span>**Documentation âš ï¸**</span>
<span id="cb14-155"><a href="#cb14-155"></a><span class="ss">   - </span>Comments in important places in the code âš ï¸</span>
<span id="cb14-156"><a href="#cb14-156"></a><span class="ss">   - </span>Documentation of the function âš ï¸</span>
<span id="cb14-157"><a href="#cb14-157"></a><span class="ss">   - </span>Read me âš ï¸</span>
<span id="cb14-158"><a href="#cb14-158"></a><span class="ss">   - </span>Documentation on juliahealth.org âŒ</span>
<span id="cb14-159"><a href="#cb14-159"></a></span>
<span id="cb14-160"><a href="#cb14-160"></a>&lt;/details&gt;</span>
<span id="cb14-161"><a href="#cb14-161"></a></span>
<span id="cb14-162"><a href="#cb14-162"></a><span class="fu">## Integrate augmentations for medical data ğŸ†™</span></span>
<span id="cb14-163"><a href="#cb14-163"></a>Augmenting medical data is a crucial step for enhancing model robustness, especially given the variations in imaging conditions and patient anatomy. </span>
<span id="cb14-164"><a href="#cb14-164"></a></span>
<span id="cb14-165"><a href="#cb14-165"></a><span class="ss">- </span>This pipeline currently supports multiple augmentation techniques:</span>
<span id="cb14-166"><a href="#cb14-166"></a><span class="ss">  - </span>Brightness transform âœ…</span>
<span id="cb14-167"><a href="#cb14-167"></a><span class="ss">  - </span>Contrast augmentation transform âœ…</span>
<span id="cb14-168"><a href="#cb14-168"></a><span class="ss">  - </span>Gamma Transform âœ…</span>
<span id="cb14-169"><a href="#cb14-169"></a><span class="ss">  - </span>Gaussian noise transform âœ…</span>
<span id="cb14-170"><a href="#cb14-170"></a><span class="ss">  - </span>Rician noise transform âœ…</span>
<span id="cb14-171"><a href="#cb14-171"></a><span class="ss">  - </span>Mirror transform âœ…</span>
<span id="cb14-172"><a href="#cb14-172"></a><span class="ss">  - </span>Scale transform ğŸ†™</span>
<span id="cb14-173"><a href="#cb14-173"></a><span class="ss">  - </span>Gaussian blur transform âœ…</span>
<span id="cb14-174"><a href="#cb14-174"></a><span class="ss">  - </span>Simulate low-resolution transform ğŸ†™</span>
<span id="cb14-175"><a href="#cb14-175"></a><span class="ss">  - </span>Elastic deformation transform ğŸ†™</span>
<span id="cb14-176"><a href="#cb14-176"></a></span>
<span id="cb14-177"><a href="#cb14-177"></a>Which have been fully integrated. Each of these methods helps the model generalize better by simulating diverse imaging scenarios.</span>
<span id="cb14-178"><a href="#cb14-178"></a></span>
<span id="cb14-179"><a href="#cb14-179"></a><span class="al">![](./Augmentations.png)</span></span>
<span id="cb14-180"><a href="#cb14-180"></a></span>
<span id="cb14-181"><a href="#cb14-181"></a>Comments:</span>
<span id="cb14-182"><a href="#cb14-182"></a></span>
<span id="cb14-183"><a href="#cb14-183"></a>Augmentations such as scaling, low-resolution simulation use interpolation that is not yet GPU-accelerated.</span>
<span id="cb14-184"><a href="#cb14-184"></a></span>
<span id="cb14-185"><a href="#cb14-185"></a>Elastic deformation with simulation of different tissue elasticities is are potential development opportunities that would further improve the model's adaptability by mimicking more complex variations found in medical imaging.</span>
<span id="cb14-186"><a href="#cb14-186"></a></span>
<span id="cb14-187"><a href="#cb14-187"></a><span class="fu">## Invertible augmentations and support test time augmentations ğŸ†™</span></span>
<span id="cb14-188"><a href="#cb14-188"></a>This section focuses on the ability to apply reversible augmentations to test data, allowing the model to be evaluated with different transformations. Only rotation is available at this time. The function <span class="in">`evaluate_patches`</span> performs this evaluation by applying specified augmentations, dividing the test data into patches, and reconstructing the full image from the patches. During testing one can choose to use of largest connected component  post processing. Metrics are calculated and results are saved for analysis.</span>
<span id="cb14-189"><a href="#cb14-189"></a></span>
<span id="cb14-190"><a href="#cb14-190"></a>&lt;details&gt;</span>
<span id="cb14-191"><a href="#cb14-191"></a>&lt;summary&gt;evaluate_test:&lt;/summary&gt;</span>
<span id="cb14-192"><a href="#cb14-192"></a></span>
<span id="cb14-193"><a href="#cb14-193"></a><span class="in">```julia</span></span>
<span id="cb14-194"><a href="#cb14-194"></a><span class="in"># ...</span></span>
<span id="cb14-195"><a href="#cb14-195"></a><span class="in">for test_group in test_groups</span></span>
<span id="cb14-196"><a href="#cb14-196"></a><span class="in">    test_data, test_label, attributes = fetch_and_preprocess_data([test_group], h5, config)</span></span>
<span id="cb14-197"><a href="#cb14-197"></a><span class="in">    results, test_metrics = evaluate_patches(test_data, test_label,  tstate, model, config)</span></span>
<span id="cb14-198"><a href="#cb14-198"></a><span class="in">    y_pred, metr = process_results(results, test_metrics, config)</span></span>
<span id="cb14-199"><a href="#cb14-199"></a><span class="in">    save_results(y_pred, attributes, config)</span></span>
<span id="cb14-200"><a href="#cb14-200"></a><span class="in">    push!(all_test_metrics, metr)</span></span>
<span id="cb14-201"><a href="#cb14-201"></a><span class="in">end</span></span>
<span id="cb14-202"><a href="#cb14-202"></a><span class="in"># ...</span></span>
<span id="cb14-203"><a href="#cb14-203"></a><span class="in">```</span></span>
<span id="cb14-204"><a href="#cb14-204"></a></span>
<span id="cb14-205"><a href="#cb14-205"></a><span class="in">```julia</span></span>
<span id="cb14-206"><a href="#cb14-206"></a><span class="in">function evaluate_patches(test_data, test_label, tstate, model, config, axis, angle)</span></span>
<span id="cb14-207"><a href="#cb14-207"></a><span class="in">    println("Evaluating patches...")</span></span>
<span id="cb14-208"><a href="#cb14-208"></a><span class="in">    results = []</span></span>
<span id="cb14-209"><a href="#cb14-209"></a><span class="in">    test_metrics = []</span></span>
<span id="cb14-210"><a href="#cb14-210"></a><span class="in">    tstates = [tstate]</span></span>
<span id="cb14-211"><a href="#cb14-211"></a><span class="in">    test_time_augs = []</span></span>
<span id="cb14-212"><a href="#cb14-212"></a></span>
<span id="cb14-213"><a href="#cb14-213"></a><span class="in">    for i in config["learning"]["n_invertible"]</span></span>
<span id="cb14-214"><a href="#cb14-214"></a><span class="in">        data = rotate_mi(test_data, axis, angle)</span></span>
<span id="cb14-215"><a href="#cb14-215"></a><span class="in">        for tstate_curr in tstates</span></span>
<span id="cb14-216"><a href="#cb14-216"></a><span class="in">            patch_results = []</span></span>
<span id="cb14-217"><a href="#cb14-217"></a><span class="in">            patch_size = Tuple(config["learning"]["patch_size"])</span></span>
<span id="cb14-218"><a href="#cb14-218"></a><span class="in">            idx_and_patches, paded_data_size = divide_into_patches(test_data, patch_size)</span></span>
<span id="cb14-219"><a href="#cb14-219"></a><span class="in">            coordinates = [patch[1] for patch in idx_and_patches]</span></span>
<span id="cb14-220"><a href="#cb14-220"></a><span class="in">            patch_data = [patch[2] for patch in idx_and_patches]</span></span>
<span id="cb14-221"><a href="#cb14-221"></a><span class="in">            for patch in patch_data</span></span>
<span id="cb14-222"><a href="#cb14-222"></a><span class="in">                y_pred_patch, _ = infer_model(tstate_curr, model, patch)</span></span>
<span id="cb14-223"><a href="#cb14-223"></a><span class="in">                push!(patch_results, y_pred_patch)</span></span>
<span id="cb14-224"><a href="#cb14-224"></a><span class="in">            end</span></span>
<span id="cb14-225"><a href="#cb14-225"></a><span class="in">            idx_and_y_pred_patch = zip(coordinates, patch_results)</span></span>
<span id="cb14-226"><a href="#cb14-226"></a><span class="in">            y_pred = recreate_image_from_patches(idx_and_y_pred_patch, paded_data_size, patch_size, size(test_data))</span></span>
<span id="cb14-227"><a href="#cb14-227"></a><span class="in">            if config["learning"]["largest_connected_component"]</span></span>
<span id="cb14-228"><a href="#cb14-228"></a><span class="in">                y_pred = largest_connected_component(y_pred, config["learning"]["n_lcc"])</span></span>
<span id="cb14-229"><a href="#cb14-229"></a><span class="in">            end</span></span>
<span id="cb14-230"><a href="#cb14-230"></a><span class="in">            metr = evaluate_metric(y_pred, test_label, config["learning"]["metric"])</span></span>
<span id="cb14-231"><a href="#cb14-231"></a><span class="in">            push!(test_metrics, metr)</span></span>
<span id="cb14-232"><a href="#cb14-232"></a><span class="in">        end</span></span>
<span id="cb14-233"><a href="#cb14-233"></a><span class="in">    end</span></span>
<span id="cb14-234"><a href="#cb14-234"></a><span class="in">    return results, test_metrics</span></span>
<span id="cb14-235"><a href="#cb14-235"></a><span class="in">end</span></span>
<span id="cb14-236"><a href="#cb14-236"></a><span class="in">```</span></span>
<span id="cb14-237"><a href="#cb14-237"></a></span>
<span id="cb14-238"><a href="#cb14-238"></a><span class="in">```julia</span></span>
<span id="cb14-239"><a href="#cb14-239"></a><span class="in">function divide_into_patches(image::AbstractArray{T, 5}, patch_size::Tuple{Int, Int, Int}) where T</span></span>
<span id="cb14-240"><a href="#cb14-240"></a><span class="in">    println("Dividing image into patches...")</span></span>
<span id="cb14-241"><a href="#cb14-241"></a><span class="in">    println("Size of the image: ", size(image)) </span></span>
<span id="cb14-242"><a href="#cb14-242"></a></span>
<span id="cb14-243"><a href="#cb14-243"></a><span class="in">    # Calculate the required padding for each dimension (W, H, D)</span></span>
<span id="cb14-244"><a href="#cb14-244"></a><span class="in">    pad_size = (</span></span>
<span id="cb14-245"><a href="#cb14-245"></a><span class="in">        (size(image, 1) % patch_size[1]) != 0 ? patch_size[1] - size(image, 1) % patch_size[1] : 0,</span></span>
<span id="cb14-246"><a href="#cb14-246"></a><span class="in">        (size(image, 2) % patch_size[2]) != 0 ? patch_size[2] - size(image, 2) % patch_size[2] : 0,</span></span>
<span id="cb14-247"><a href="#cb14-247"></a><span class="in">        (size(image, 3) % patch_size[3]) != 0 ? patch_size[3] - size(image, 3) % patch_size[3] : 0</span></span>
<span id="cb14-248"><a href="#cb14-248"></a><span class="in">    )</span></span>
<span id="cb14-249"><a href="#cb14-249"></a></span>
<span id="cb14-250"><a href="#cb14-250"></a><span class="in">    # Pad the image if necessary</span></span>
<span id="cb14-251"><a href="#cb14-251"></a><span class="in">    padded_image = image</span></span>
<span id="cb14-252"><a href="#cb14-252"></a><span class="in">    if any(pad_size .&gt; 0)</span></span>
<span id="cb14-253"><a href="#cb14-253"></a><span class="in">        padded_image = crop_or_pad(image, (size(image, 1) + pad_size[1], size(image, 2) + pad_size[2], size(image, 3) + pad_size[3]))</span></span>
<span id="cb14-254"><a href="#cb14-254"></a><span class="in">    end</span></span>
<span id="cb14-255"><a href="#cb14-255"></a></span>
<span id="cb14-256"><a href="#cb14-256"></a><span class="in">    # Extract patches</span></span>
<span id="cb14-257"><a href="#cb14-257"></a><span class="in">    patches = []</span></span>
<span id="cb14-258"><a href="#cb14-258"></a><span class="in">    for x in 1:patch_size[1]:size(padded_image, 1)</span></span>
<span id="cb14-259"><a href="#cb14-259"></a><span class="in">        for y in 1:patch_size[2]:size(padded_image, 2)</span></span>
<span id="cb14-260"><a href="#cb14-260"></a><span class="in">            for z in 1:patch_size[3]:size(padded_image, 3)</span></span>
<span id="cb14-261"><a href="#cb14-261"></a><span class="in">                patch = view(</span></span>
<span id="cb14-262"><a href="#cb14-262"></a><span class="in">                    padded_image,</span></span>
<span id="cb14-263"><a href="#cb14-263"></a><span class="in">                    x:min(x+patch_size[1]-1, size(padded_image, 1)),</span></span>
<span id="cb14-264"><a href="#cb14-264"></a><span class="in">                    y:min(y+patch_size[2]-1, size(padded_image, 2)),</span></span>
<span id="cb14-265"><a href="#cb14-265"></a><span class="in">                    z:min(z+patch_size[3]-1, size(padded_image, 3)),</span></span>
<span id="cb14-266"><a href="#cb14-266"></a><span class="in">                    :,</span></span>
<span id="cb14-267"><a href="#cb14-267"></a><span class="in">                    :</span></span>
<span id="cb14-268"><a href="#cb14-268"></a><span class="in">                )</span></span>
<span id="cb14-269"><a href="#cb14-269"></a><span class="in">                push!(patches, [(x, y, z), patch])</span></span>
<span id="cb14-270"><a href="#cb14-270"></a><span class="in">            end</span></span>
<span id="cb14-271"><a href="#cb14-271"></a><span class="in">        end</span></span>
<span id="cb14-272"><a href="#cb14-272"></a><span class="in">    end</span></span>
<span id="cb14-273"><a href="#cb14-273"></a><span class="in">    println("Size of padded image: ", size(padded_image))</span></span>
<span id="cb14-274"><a href="#cb14-274"></a><span class="in">    return patches, size(padded_image)</span></span>
<span id="cb14-275"><a href="#cb14-275"></a><span class="in">end</span></span>
<span id="cb14-276"><a href="#cb14-276"></a></span>
<span id="cb14-277"><a href="#cb14-277"></a><span class="in">function recreate_image_from_patches(</span></span>
<span id="cb14-278"><a href="#cb14-278"></a><span class="in">    coords_with_patches,</span></span>
<span id="cb14-279"><a href="#cb14-279"></a><span class="in">    padded_size,</span></span>
<span id="cb14-280"><a href="#cb14-280"></a><span class="in">    patch_size,</span></span>
<span id="cb14-281"><a href="#cb14-281"></a><span class="in">    original_size</span></span>
<span id="cb14-282"><a href="#cb14-282"></a><span class="in">)</span></span>
<span id="cb14-283"><a href="#cb14-283"></a><span class="in">    println("Recreating image from patches...")</span></span>
<span id="cb14-284"><a href="#cb14-284"></a><span class="in">    reconstructed_image = zeros(Float32, padded_size...)</span></span>
<span id="cb14-285"><a href="#cb14-285"></a><span class="in">    </span></span>
<span id="cb14-286"><a href="#cb14-286"></a><span class="in">    # Place patches back into their original positions</span></span>
<span id="cb14-287"><a href="#cb14-287"></a><span class="in">    for (coords, patch) in coords_with_patches</span></span>
<span id="cb14-288"><a href="#cb14-288"></a><span class="in">        x, y, z = coords</span></span>
<span id="cb14-289"><a href="#cb14-289"></a><span class="in">        reconstructed_image[</span></span>
<span id="cb14-290"><a href="#cb14-290"></a><span class="in">            x:x+patch_size[1]-1,</span></span>
<span id="cb14-291"><a href="#cb14-291"></a><span class="in">            y:y+patch_size[2]-1,</span></span>
<span id="cb14-292"><a href="#cb14-292"></a><span class="in">            z:z+patch_size[3]-1,</span></span>
<span id="cb14-293"><a href="#cb14-293"></a><span class="in">            :,</span></span>
<span id="cb14-294"><a href="#cb14-294"></a><span class="in">            :</span></span>
<span id="cb14-295"><a href="#cb14-295"></a><span class="in">        ] = patch</span></span>
<span id="cb14-296"><a href="#cb14-296"></a><span class="in">    end</span></span>
<span id="cb14-297"><a href="#cb14-297"></a></span>
<span id="cb14-298"><a href="#cb14-298"></a><span class="in">    # Crop the reconstructed image to remove any padding</span></span>
<span id="cb14-299"><a href="#cb14-299"></a><span class="in">    final_image = reconstructed_image[</span></span>
<span id="cb14-300"><a href="#cb14-300"></a><span class="in">        1:original_size[1],</span></span>
<span id="cb14-301"><a href="#cb14-301"></a><span class="in">        1:original_size[2],</span></span>
<span id="cb14-302"><a href="#cb14-302"></a><span class="in">        1:original_size[3],</span></span>
<span id="cb14-303"><a href="#cb14-303"></a><span class="in">        :,</span></span>
<span id="cb14-304"><a href="#cb14-304"></a><span class="in">        :</span></span>
<span id="cb14-305"><a href="#cb14-305"></a><span class="in">    ]</span></span>
<span id="cb14-306"><a href="#cb14-306"></a><span class="in">    println("Size of the final image: ", size(final_image))</span></span>
<span id="cb14-307"><a href="#cb14-307"></a><span class="in">    return final_image</span></span>
<span id="cb14-308"><a href="#cb14-308"></a><span class="in">end</span></span>
<span id="cb14-309"><a href="#cb14-309"></a><span class="in">```</span></span>
<span id="cb14-310"><a href="#cb14-310"></a>&lt;/details&gt;</span>
<span id="cb14-311"><a href="#cb14-311"></a></span>
<span id="cb14-312"><a href="#cb14-312"></a>Comment:&lt;br&gt;</span>
<span id="cb14-313"><a href="#cb14-313"></a>In this section, there is significant potential to incorporate additional types of invertible augmentations.</span>
<span id="cb14-314"><a href="#cb14-314"></a></span>
<span id="cb14-315"><a href="#cb14-315"></a><span class="fu">## Patch-based data loading with probabilistic oversampling âœ…</span></span>
<span id="cb14-316"><a href="#cb14-316"></a>In this section, patches are extracted using <span class="in">`extract_patch`</span> from the medical images for model training, with a probability-based method to decide between a random patch or a patch with non-zero labels.</span>
<span id="cb14-317"><a href="#cb14-317"></a>Helper functions like <span class="in">`get_random_patch`</span> and <span class="in">`get_centered_patch`</span> determine the starting indices and dimensions for the patches based on given configurations, while padding methods ensure consistency even if the patch exceeds the original image dimensions. Probabilistic oversampling, as configured, allows for more balanced and informative data sampling, which improves the model's ability to detect specific medical features.</span>
<span id="cb14-318"><a href="#cb14-318"></a></span>
<span id="cb14-319"><a href="#cb14-319"></a></span>
<span id="cb14-320"><a href="#cb14-320"></a>&lt;details&gt;</span>
<span id="cb14-321"><a href="#cb14-321"></a>&lt;summary&gt;extract_patch:&lt;/summary&gt;</span>
<span id="cb14-322"><a href="#cb14-322"></a></span>
<span id="cb14-323"><a href="#cb14-323"></a><span class="in">```julia</span></span>
<span id="cb14-324"><a href="#cb14-324"></a><span class="in">function extract_patch(image, label, patch_size, config)</span></span>
<span id="cb14-325"><a href="#cb14-325"></a><span class="in">    # Fetch the oversampling probability from the config</span></span>
<span id="cb14-326"><a href="#cb14-326"></a><span class="in">    println("Extracting patch.")</span></span>
<span id="cb14-327"><a href="#cb14-327"></a><span class="in">    oversampling_probability = config["learning"]["oversampling_probability"]</span></span>
<span id="cb14-328"><a href="#cb14-328"></a><span class="in">    # Generate a random number to decide which patch extraction method to use</span></span>
<span id="cb14-329"><a href="#cb14-329"></a><span class="in">    random_choice = rand()</span></span>
<span id="cb14-330"><a href="#cb14-330"></a></span>
<span id="cb14-331"><a href="#cb14-331"></a><span class="in">    if random_choice &lt;= oversampling_probability</span></span>
<span id="cb14-332"><a href="#cb14-332"></a><span class="in">        return extract_nonzero_patch(image, label, patch_size)</span></span>
<span id="cb14-333"><a href="#cb14-333"></a><span class="in">    else</span></span>
<span id="cb14-334"><a href="#cb14-334"></a></span>
<span id="cb14-335"><a href="#cb14-335"></a><span class="in">        return get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-336"><a href="#cb14-336"></a><span class="in">    end</span></span>
<span id="cb14-337"><a href="#cb14-337"></a><span class="in">end</span></span>
<span id="cb14-338"><a href="#cb14-338"></a><span class="in">#Helper function, in case the mask is emptyClick to apply</span></span>
<span id="cb14-339"><a href="#cb14-339"></a><span class="in">function extract_nonzero_patch(image, label, patch_size)</span></span>
<span id="cb14-340"><a href="#cb14-340"></a><span class="in">    println("Extracting a patch centered around a non-zero label value.")</span></span>
<span id="cb14-341"><a href="#cb14-341"></a><span class="in">    indices = findall(x -&gt; x != 0, label)</span></span>
<span id="cb14-342"><a href="#cb14-342"></a><span class="in">    if isempty(indices)</span></span>
<span id="cb14-343"><a href="#cb14-343"></a><span class="in">        # Fallback to random patch if no non-zero points are found</span></span>
<span id="cb14-344"><a href="#cb14-344"></a><span class="in">        return get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-345"><a href="#cb14-345"></a><span class="in">    else</span></span>
<span id="cb14-346"><a href="#cb14-346"></a><span class="in">        # Choose a random non-zero index to center the patch around</span></span>
<span id="cb14-347"><a href="#cb14-347"></a><span class="in">        center = indices[rand(1:length(indices))]</span></span>
<span id="cb14-348"><a href="#cb14-348"></a><span class="in">        return get_centered_patch(image, label, center, patch_size)</span></span>
<span id="cb14-349"><a href="#cb14-349"></a><span class="in">    end</span></span>
<span id="cb14-350"><a href="#cb14-350"></a><span class="in">end</span></span>
<span id="cb14-351"><a href="#cb14-351"></a><span class="in"># Function to get a patch centered around a specific index</span></span>
<span id="cb14-352"><a href="#cb14-352"></a><span class="in">function get_centered_patch(image, label, center, patch_size)</span></span>
<span id="cb14-353"><a href="#cb14-353"></a><span class="in">    center_coords = Tuple(center)</span></span>
<span id="cb14-354"><a href="#cb14-354"></a><span class="in">    half_patch = patch_size .Ã· 2</span></span>
<span id="cb14-355"><a href="#cb14-355"></a><span class="in">    start_indices = center_coords .- half_patch</span></span>
<span id="cb14-356"><a href="#cb14-356"></a><span class="in">    end_indices = start_indices .+ patch_size .- 1</span></span>
<span id="cb14-357"><a href="#cb14-357"></a></span>
<span id="cb14-358"><a href="#cb14-358"></a><span class="in">    # Calculate padding needed</span></span>
<span id="cb14-359"><a href="#cb14-359"></a><span class="in">    pad_beg = (</span></span>
<span id="cb14-360"><a href="#cb14-360"></a><span class="in">        max(1 - start_indices[1], 0),</span></span>
<span id="cb14-361"><a href="#cb14-361"></a><span class="in">        max(1 - start_indices[2], 0),</span></span>
<span id="cb14-362"><a href="#cb14-362"></a><span class="in">        max(1 - start_indices[3], 0)</span></span>
<span id="cb14-363"><a href="#cb14-363"></a><span class="in">    )</span></span>
<span id="cb14-364"><a href="#cb14-364"></a><span class="in">    pad_end = (</span></span>
<span id="cb14-365"><a href="#cb14-365"></a><span class="in">        max(end_indices[1] - size(image, 1), 0),</span></span>
<span id="cb14-366"><a href="#cb14-366"></a><span class="in">        max(end_indices[2] - size(image, 2), 0),</span></span>
<span id="cb14-367"><a href="#cb14-367"></a><span class="in">        max(end_indices[3] - size(image, 3), 0)</span></span>
<span id="cb14-368"><a href="#cb14-368"></a><span class="in">    )</span></span>
<span id="cb14-369"><a href="#cb14-369"></a></span>
<span id="cb14-370"><a href="#cb14-370"></a><span class="in">    # Adjust start_indices and end_indices after padding</span></span>
<span id="cb14-371"><a href="#cb14-371"></a><span class="in">    start_indices_adj = start_indices .+ pad_beg</span></span>
<span id="cb14-372"><a href="#cb14-372"></a><span class="in">    end_indices_adj = end_indices .+ pad_beg</span></span>
<span id="cb14-373"><a href="#cb14-373"></a></span>
<span id="cb14-374"><a href="#cb14-374"></a><span class="in">    # Convert padding values to integers</span></span>
<span id="cb14-375"><a href="#cb14-375"></a><span class="in">    pad_beg = Tuple(round.(Int, pad_beg))</span></span>
<span id="cb14-376"><a href="#cb14-376"></a><span class="in">    pad_end = Tuple(round.(Int, pad_end))</span></span>
<span id="cb14-377"><a href="#cb14-377"></a></span>
<span id="cb14-378"><a href="#cb14-378"></a><span class="in">    # Pad the image and label using pad_mi</span></span>
<span id="cb14-379"><a href="#cb14-379"></a><span class="in">    image_padded = pad_mi(image, pad_beg, pad_end, 0)</span></span>
<span id="cb14-380"><a href="#cb14-380"></a><span class="in">    label_padded = pad_mi(label, pad_beg, pad_end, 0)</span></span>
<span id="cb14-381"><a href="#cb14-381"></a></span>
<span id="cb14-382"><a href="#cb14-382"></a><span class="in">    # Extract the patch</span></span>
<span id="cb14-383"><a href="#cb14-383"></a><span class="in">    image_patch = image_padded[</span></span>
<span id="cb14-384"><a href="#cb14-384"></a><span class="in">        start_indices_adj[1]:end_indices_adj[1],</span></span>
<span id="cb14-385"><a href="#cb14-385"></a><span class="in">        start_indices_adj[2]:end_indices_adj[2],</span></span>
<span id="cb14-386"><a href="#cb14-386"></a><span class="in">        start_indices_adj[3]:end_indices_adj[3]</span></span>
<span id="cb14-387"><a href="#cb14-387"></a><span class="in">    ]</span></span>
<span id="cb14-388"><a href="#cb14-388"></a><span class="in">    label_patch = label_padded[</span></span>
<span id="cb14-389"><a href="#cb14-389"></a><span class="in">        start_indices_adj[1]:end_indices_adj[1],</span></span>
<span id="cb14-390"><a href="#cb14-390"></a><span class="in">        start_indices_adj[2]:end_indices_adj[2],</span></span>
<span id="cb14-391"><a href="#cb14-391"></a><span class="in">        start_indices_adj[3]:end_indices_adj[3]</span></span>
<span id="cb14-392"><a href="#cb14-392"></a><span class="in">    ]</span></span>
<span id="cb14-393"><a href="#cb14-393"></a></span>
<span id="cb14-394"><a href="#cb14-394"></a><span class="in">    return image_patch, label_patch</span></span>
<span id="cb14-395"><a href="#cb14-395"></a><span class="in">end</span></span>
<span id="cb14-396"><a href="#cb14-396"></a></span>
<span id="cb14-397"><a href="#cb14-397"></a><span class="in">function get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-398"><a href="#cb14-398"></a><span class="in">    println("Extracting a random patch.")</span></span>
<span id="cb14-399"><a href="#cb14-399"></a><span class="in">    # Check if the patch size is greater than the image dimensions</span></span>
<span id="cb14-400"><a href="#cb14-400"></a><span class="in">    if any(patch_size .&gt; size(image))</span></span>
<span id="cb14-401"><a href="#cb14-401"></a><span class="in">        # Calculate the needed size to fit the patch</span></span>
<span id="cb14-402"><a href="#cb14-402"></a><span class="in">        needed_size = map(max, size(image), patch_size)</span></span>
<span id="cb14-403"><a href="#cb14-403"></a><span class="in">        # Use crop_or_pad to ensure the image and label are at least as large as needed_size</span></span>
<span id="cb14-404"><a href="#cb14-404"></a><span class="in">        image = crop_or_pad(image, needed_size)</span></span>
<span id="cb14-405"><a href="#cb14-405"></a><span class="in">        label = crop_or_pad(label, needed_size)</span></span>
<span id="cb14-406"><a href="#cb14-406"></a><span class="in">    end</span></span>
<span id="cb14-407"><a href="#cb14-407"></a></span>
<span id="cb14-408"><a href="#cb14-408"></a><span class="in">    # Calculate random start indices within the new allowable range</span></span>
<span id="cb14-409"><a href="#cb14-409"></a><span class="in">    start_x = rand(1:size(image, 1) - patch_size[1] + 1)</span></span>
<span id="cb14-410"><a href="#cb14-410"></a><span class="in">    start_y = rand(1:size(image, 2) - patch_size[2] + 1)</span></span>
<span id="cb14-411"><a href="#cb14-411"></a><span class="in">    start_z = rand(1:size(image, 3) - patch_size[3] + 1)</span></span>
<span id="cb14-412"><a href="#cb14-412"></a><span class="in">    start_indices = [start_x, start_y, start_z]</span></span>
<span id="cb14-413"><a href="#cb14-413"></a><span class="in">    end_indices = start_indices .+ patch_size .- 1</span></span>
<span id="cb14-414"><a href="#cb14-414"></a></span>
<span id="cb14-415"><a href="#cb14-415"></a><span class="in">    # Extract the patch directly when within bounds</span></span>
<span id="cb14-416"><a href="#cb14-416"></a><span class="in">    image_patch = image[start_indices[1]:end_indices[1], start_indices[2]:end_indices[2], start_indices[3]:end_indices[3]]</span></span>
<span id="cb14-417"><a href="#cb14-417"></a><span class="in">    label_patch = label[start_indices[1]:end_indices[1], start_indices[2]:end_indices[2], start_indices[3]:end_indices[3]]</span></span>
<span id="cb14-418"><a href="#cb14-418"></a></span>
<span id="cb14-419"><a href="#cb14-419"></a><span class="in">    return image_patch, label_patch</span></span>
<span id="cb14-420"><a href="#cb14-420"></a><span class="in">end</span></span>
<span id="cb14-421"><a href="#cb14-421"></a></span>
<span id="cb14-422"><a href="#cb14-422"></a><span class="in">```</span></span>
<span id="cb14-423"><a href="#cb14-423"></a>&lt;/details&gt;</span>
<span id="cb14-424"><a href="#cb14-424"></a></span>
<span id="cb14-425"><a href="#cb14-425"></a><span class="fu">## Calculate Median and Mean Spacing with resampling ğŸ†™</span></span>
<span id="cb14-426"><a href="#cb14-426"></a>This part ensures that all images in the dataset have consistent real coordinates, spacing, shape. It's a critical factor in medical imaging for accurate analysis. By calculating and applying set values, median or mean across images ensures uniformity.</span>
<span id="cb14-427"><a href="#cb14-427"></a></span>
<span id="cb14-428"><a href="#cb14-428"></a><span class="fu">#### Resample images to target image ğŸ†™</span></span>
<span id="cb14-429"><a href="#cb14-429"></a>This step aligns each image to the reference coordinates main image, ensuring that all images share a common spatial alignment. The <span class="in">`resample_to_image`</span> function from MedImage.jl is used here, applying interpolation to adjust each image.</span>
<span id="cb14-430"><a href="#cb14-430"></a></span>
<span id="cb14-431"><a href="#cb14-431"></a></span>
<span id="cb14-432"><a href="#cb14-432"></a>&lt;details&gt;</span>
<span id="cb14-433"><a href="#cb14-433"></a>&lt;summary&gt;resample_images_to_target:&lt;/summary&gt;</span>
<span id="cb14-434"><a href="#cb14-434"></a></span>
<span id="cb14-435"><a href="#cb14-435"></a><span class="in">```julia</span></span>
<span id="cb14-436"><a href="#cb14-436"></a><span class="in">if resample_images_to_target &amp;&amp; !isempty(Med_images)</span></span>
<span id="cb14-437"><a href="#cb14-437"></a><span class="in">    println("Resampling $channel_type files in channel '$channel_folder' to the first $channel_type in the channel.")</span></span>
<span id="cb14-438"><a href="#cb14-438"></a><span class="in">    reference_image = Med_images[1]</span></span>
<span id="cb14-439"><a href="#cb14-439"></a><span class="in">    Med_images = [resample_to_image(reference_image, img, interpolator) for img in Med_images]</span></span>
<span id="cb14-440"><a href="#cb14-440"></a><span class="in">end</span></span>
<span id="cb14-441"><a href="#cb14-441"></a><span class="in">```</span></span>
<span id="cb14-442"><a href="#cb14-442"></a>&lt;/details&gt;</span>
<span id="cb14-443"><a href="#cb14-443"></a></span>
<span id="cb14-444"><a href="#cb14-444"></a>Comment:&lt;br&gt;</span>
<span id="cb14-445"><a href="#cb14-445"></a><span class="in">`Resample_to_image`</span> uses interpolation that is not yet GPU-accelerated in this implementation, this step slow down the data preparation phase significantly.</span>
<span id="cb14-446"><a href="#cb14-446"></a></span>
<span id="cb14-447"><a href="#cb14-447"></a><span class="fu">#### Ensure uniform spacing across the entire dataset ğŸ†™</span></span>
<span id="cb14-448"><a href="#cb14-448"></a>This step brings all images to a consistent voxel spacing across the dataset using <span class="in">`resample_to_spacing`</span> from MedImage.jl. This uniform spacing is crucial for creating a standardized dataset where each image voxel represents the same physical volume.</span>
<span id="cb14-449"><a href="#cb14-449"></a></span>
<span id="cb14-450"><a href="#cb14-450"></a></span>
<span id="cb14-451"><a href="#cb14-451"></a>&lt;details&gt;</span>
<span id="cb14-452"><a href="#cb14-452"></a>&lt;summary&gt;esample_to_spacing:&lt;/summary&gt;</span>
<span id="cb14-453"><a href="#cb14-453"></a></span>
<span id="cb14-454"><a href="#cb14-454"></a><span class="in">```julia</span></span>
<span id="cb14-455"><a href="#cb14-455"></a><span class="in">if resample_images_spacing == "set"</span></span>
<span id="cb14-456"><a href="#cb14-456"></a><span class="in">    println("Resampling all $channel_type files to target spacing: $target_spacing")</span></span>
<span id="cb14-457"><a href="#cb14-457"></a><span class="in">    target_spacing = Tuple(Float32(s) for s in target_spacing)</span></span>
<span id="cb14-458"><a href="#cb14-458"></a><span class="in">    channels_data = [[resample_to_spacing(img, target_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-459"><a href="#cb14-459"></a><span class="in">elseif resample_images_spacing == "avg"</span></span>
<span id="cb14-460"><a href="#cb14-460"></a><span class="in">    println("Calculating average spacing across all $channel_type files and resampling.")</span></span>
<span id="cb14-461"><a href="#cb14-461"></a><span class="in">    all_spacings = [img.spacing for channel in channels_data for img in channel]</span></span>
<span id="cb14-462"><a href="#cb14-462"></a><span class="in">    avg_spacing = Tuple(Float32(mean(s)) for s in zip(all_spacings...))</span></span>
<span id="cb14-463"><a href="#cb14-463"></a><span class="in">    println("Average spacing calculated: $avg_spacing")</span></span>
<span id="cb14-464"><a href="#cb14-464"></a><span class="in">    channels_data = [[resample_to_spacing(img, avg_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-465"><a href="#cb14-465"></a><span class="in">elseif resample_images_spacing == "median"</span></span>
<span id="cb14-466"><a href="#cb14-466"></a><span class="in">    println("Calculating median spacing across all $channel_type files and resampling.")</span></span>
<span id="cb14-467"><a href="#cb14-467"></a><span class="in">    all_spacings = [img.spacing for channel in channels_data for img in channel]</span></span>
<span id="cb14-468"><a href="#cb14-468"></a><span class="in">    median_spacing = Tuple(Float32(median(s)) for s in all_spacings)</span></span>
<span id="cb14-469"><a href="#cb14-469"></a><span class="in">    println("Median spacing calculated: $median_spacing")</span></span>
<span id="cb14-470"><a href="#cb14-470"></a><span class="in">    channels_data = [[resample_to_spacing(img, median_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-471"><a href="#cb14-471"></a><span class="in">elseif resample_images_spacing == false</span></span>
<span id="cb14-472"><a href="#cb14-472"></a><span class="in">    println("Skipping resampling of $channel_type files.")</span></span>
<span id="cb14-473"><a href="#cb14-473"></a><span class="in">    # No resampling will be applied, channels_data remains unchanged.</span></span>
<span id="cb14-474"><a href="#cb14-474"></a><span class="in">end</span></span>
<span id="cb14-475"><a href="#cb14-475"></a><span class="in">```</span></span>
<span id="cb14-476"><a href="#cb14-476"></a>&lt;/details&gt;</span>
<span id="cb14-477"><a href="#cb14-477"></a></span>
<span id="cb14-478"><a href="#cb14-478"></a>Comment:&lt;br&gt;</span>
<span id="cb14-479"><a href="#cb14-479"></a><span class="in">`Resample_to_spacing`</span> uses interpolation that is not yet GPU-accelerated in this implementation, this step slow down the data preparation phase significantly.</span>
<span id="cb14-480"><a href="#cb14-480"></a></span>
<span id="cb14-481"><a href="#cb14-481"></a><span class="fu">#### Resizing all channels files to average or target size âœ…</span></span>
<span id="cb14-482"><a href="#cb14-482"></a>To create a cohesive 5D tensor, all images in each channel are resized to a uniform shape, either the average size of all images or a specific target size. This resizing process uses <span class="in">`crop_or_pad`</span>, ensuring that all images match the specified dimensions, making them suitable for model input.</span>
<span id="cb14-483"><a href="#cb14-483"></a></span>
<span id="cb14-484"><a href="#cb14-484"></a>&lt;details&gt;</span>
<span id="cb14-485"><a href="#cb14-485"></a>&lt;summary&gt;crop_or_pad:&lt;/summary&gt;</span>
<span id="cb14-486"><a href="#cb14-486"></a></span>
<span id="cb14-487"><a href="#cb14-487"></a><span class="in">```julia</span></span>
<span id="cb14-488"><a href="#cb14-488"></a><span class="in">if resample_size == "avg"</span></span>
<span id="cb14-489"><a href="#cb14-489"></a><span class="in">    sizes = [size(img.voxel_data) for img in channels_data for img in img]  # Get sizes from all images</span></span>
<span id="cb14-490"><a href="#cb14-490"></a><span class="in">    avg_dim = map(mean, zip(sizes...))</span></span>
<span id="cb14-491"><a href="#cb14-491"></a><span class="in">    avg_dim = Tuple(Int(round(d)) for d in avg_dim)</span></span>
<span id="cb14-492"><a href="#cb14-492"></a><span class="in">    println("Resizing all $channel_type files to average dimension: $avg_dim")</span></span>
<span id="cb14-493"><a href="#cb14-493"></a><span class="in">    channels_data = [[crop_or_pad(img, avg_dim) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-494"><a href="#cb14-494"></a><span class="in">elseif resample_size != "avg"</span></span>
<span id="cb14-495"><a href="#cb14-495"></a><span class="in">    target_dim = Tuple(resample_size)</span></span>
<span id="cb14-496"><a href="#cb14-496"></a><span class="in">    println("Resizing all $channel_type files to target dimension: $target_dim")</span></span>
<span id="cb14-497"><a href="#cb14-497"></a><span class="in">    channels_data = [[crop_or_pad(img, target_dim) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-498"><a href="#cb14-498"></a><span class="in">end</span></span>
<span id="cb14-499"><a href="#cb14-499"></a><span class="in">```</span></span>
<span id="cb14-500"><a href="#cb14-500"></a>&lt;/details&gt;</span>
<span id="cb14-501"><a href="#cb14-501"></a></span>
<span id="cb14-502"><a href="#cb14-502"></a><span class="fu">## Basic Post-processing operations</span></span>
<span id="cb14-503"><a href="#cb14-503"></a>Post-processing operations involve algorithm <span class="in">`largest_connected_components`</span>. It is achieved by label initialization and propagation in the segmented mask.</span>
<span id="cb14-504"><a href="#cb14-504"></a><span class="in">`Initialize_labels_kernel`</span> function assigns unique labels to different regions.</span>
<span id="cb14-505"><a href="#cb14-505"></a></span>
<span id="cb14-506"><a href="#cb14-506"></a>&lt;details&gt;</span>
<span id="cb14-507"><a href="#cb14-507"></a>&lt;summary&gt;initialize_labels_kernel:&lt;/summary&gt;</span>
<span id="cb14-508"><a href="#cb14-508"></a></span>
<span id="cb14-509"><a href="#cb14-509"></a><span class="in">```julia</span></span>
<span id="cb14-510"><a href="#cb14-510"></a><span class="in">@kernel function initialize_labels_kernel(mask, labels, width, height, depth)</span></span>
<span id="cb14-511"><a href="#cb14-511"></a><span class="in">    idx = @index(Global, Cartesian)</span></span>
<span id="cb14-512"><a href="#cb14-512"></a><span class="in">    i = idx[1]</span></span>
<span id="cb14-513"><a href="#cb14-513"></a><span class="in">    j = idx[2]</span></span>
<span id="cb14-514"><a href="#cb14-514"></a><span class="in">    k = idx[3]</span></span>
<span id="cb14-515"><a href="#cb14-515"></a><span class="in">    </span></span>
<span id="cb14-516"><a href="#cb14-516"></a><span class="in">    if i &gt;= 1 &amp;&amp; i &lt;= width &amp;&amp; j &gt;= 1 &amp;&amp; j &lt;= height &amp;&amp; k &gt;= 1 &amp;&amp; k &lt;= depth</span></span>
<span id="cb14-517"><a href="#cb14-517"></a><span class="in">        if mask[i, j, k] == 1</span></span>
<span id="cb14-518"><a href="#cb14-518"></a><span class="in">            labels[i, j, k] = i + (j - 1) * width + (k - 1) * width * height</span></span>
<span id="cb14-519"><a href="#cb14-519"></a><span class="in">        else</span></span>
<span id="cb14-520"><a href="#cb14-520"></a><span class="in">            labels[i, j, k] = 0</span></span>
<span id="cb14-521"><a href="#cb14-521"></a><span class="in">        end</span></span>
<span id="cb14-522"><a href="#cb14-522"></a><span class="in">    end</span></span>
<span id="cb14-523"><a href="#cb14-523"></a><span class="in">end</span></span>
<span id="cb14-524"><a href="#cb14-524"></a><span class="in">```</span></span>
<span id="cb14-525"><a href="#cb14-525"></a>&lt;/details&gt;</span>
<span id="cb14-526"><a href="#cb14-526"></a>Propagate_labels_kernel iteratively updates the labels to maintain connected regions.</span>
<span id="cb14-527"><a href="#cb14-527"></a>propagate_labels_kernel:</span>
<span id="cb14-528"><a href="#cb14-528"></a>&lt;details&gt;</span>
<span id="cb14-529"><a href="#cb14-529"></a></span>
<span id="cb14-530"><a href="#cb14-530"></a><span class="in">```julia</span></span>
<span id="cb14-531"><a href="#cb14-531"></a><span class="in">@kernel function propagate_labels_kernel(mask, labels, width, height, depth)</span></span>
<span id="cb14-532"><a href="#cb14-532"></a><span class="in">    idx= @index(Global, Cartesian)</span></span>
<span id="cb14-533"><a href="#cb14-533"></a><span class="in">    i = idx[1]</span></span>
<span id="cb14-534"><a href="#cb14-534"></a><span class="in">    j = idx[2]</span></span>
<span id="cb14-535"><a href="#cb14-535"></a><span class="in">    k = idx[3]</span></span>
<span id="cb14-536"><a href="#cb14-536"></a></span>
<span id="cb14-537"><a href="#cb14-537"></a><span class="in">    if i &gt;= 1 &amp;&amp; i &lt;= width &amp;&amp; j &gt;= 1 &amp;&amp; j &lt;= height &amp;&amp; k &gt;= 1 &amp;&amp; k &lt;= depth</span></span>
<span id="cb14-538"><a href="#cb14-538"></a><span class="in">        if mask[i, j, k] == 1</span></span>
<span id="cb14-539"><a href="#cb14-539"></a><span class="in">            current_label = labels[i, j, k]</span></span>
<span id="cb14-540"><a href="#cb14-540"></a><span class="in">            for di in -1:1</span></span>
<span id="cb14-541"><a href="#cb14-541"></a><span class="in">                for dj in -1:1</span></span>
<span id="cb14-542"><a href="#cb14-542"></a><span class="in">                    for dk in -1:1</span></span>
<span id="cb14-543"><a href="#cb14-543"></a><span class="in">                        if di == 0 &amp;&amp; dj == 0 &amp;&amp; dk == 0</span></span>
<span id="cb14-544"><a href="#cb14-544"></a><span class="in">                            continue</span></span>
<span id="cb14-545"><a href="#cb14-545"></a><span class="in">                        end</span></span>
<span id="cb14-546"><a href="#cb14-546"></a><span class="in">                        ni = i + di</span></span>
<span id="cb14-547"><a href="#cb14-547"></a><span class="in">                        nj = j + dj</span></span>
<span id="cb14-548"><a href="#cb14-548"></a><span class="in">                        nk = k + dk</span></span>
<span id="cb14-549"><a href="#cb14-549"></a><span class="in">                        if ni &gt;= 1 &amp;&amp; ni &lt;= width &amp;&amp; nj &gt;= 1 &amp;&amp; nj &lt;= height &amp;&amp; nk &gt;= 1 &amp;&amp; nk &lt;= depth</span></span>
<span id="cb14-550"><a href="#cb14-550"></a><span class="in">                            if mask[ni, nj, nk] == 1 &amp;&amp; labels[ni, nj, nk] &lt; current_label</span></span>
<span id="cb14-551"><a href="#cb14-551"></a><span class="in">                                labels[i, j, k] = labels[ni, nj, nk]</span></span>
<span id="cb14-552"><a href="#cb14-552"></a><span class="in">                            end</span></span>
<span id="cb14-553"><a href="#cb14-553"></a><span class="in">                        end</span></span>
<span id="cb14-554"><a href="#cb14-554"></a><span class="in">                    end</span></span>
<span id="cb14-555"><a href="#cb14-555"></a><span class="in">                end</span></span>
<span id="cb14-556"><a href="#cb14-556"></a><span class="in">            end</span></span>
<span id="cb14-557"><a href="#cb14-557"></a><span class="in">        end</span></span>
<span id="cb14-558"><a href="#cb14-558"></a><span class="in">    end</span></span>
<span id="cb14-559"><a href="#cb14-559"></a><span class="in">end</span></span>
<span id="cb14-560"><a href="#cb14-560"></a><span class="in">```</span></span>
<span id="cb14-561"><a href="#cb14-561"></a>&lt;/details&gt;</span>
<span id="cb14-562"><a href="#cb14-562"></a>This process facilitates the identification of the largest connected components in 3D space, helping to isolate relevant medical structures, such as tumors, in the segmented mask. Giving the opportunity to determine how many such areas are to be returned.</span>
<span id="cb14-563"><a href="#cb14-563"></a></span>
<span id="cb14-564"><a href="#cb14-564"></a>&lt;details&gt;</span>
<span id="cb14-565"><a href="#cb14-565"></a>&lt;summary&gt;largest_connected_components:&lt;/summary&gt;</span>
<span id="cb14-566"><a href="#cb14-566"></a></span>
<span id="cb14-567"><a href="#cb14-567"></a><span class="in">```julia</span></span>
<span id="cb14-568"><a href="#cb14-568"></a><span class="in">function largest_connected_components(mask::Array{Int32, 3}, n_lcc::Int)</span></span>
<span id="cb14-569"><a href="#cb14-569"></a><span class="in">    width, height, depth = size(mask)</span></span>
<span id="cb14-570"><a href="#cb14-570"></a><span class="in">    mask_gpu = CuArray(mask)</span></span>
<span id="cb14-571"><a href="#cb14-571"></a><span class="in">    labels_gpu = CUDA.fill(0, size(mask))</span></span>
<span id="cb14-572"><a href="#cb14-572"></a><span class="in">    dev = get_backend(labels_gpu)</span></span>
<span id="cb14-573"><a href="#cb14-573"></a><span class="in">    ndrange = (width, height, depth)</span></span>
<span id="cb14-574"><a href="#cb14-574"></a><span class="in">    workgroupsize = (3, 3, 3)</span></span>
<span id="cb14-575"><a href="#cb14-575"></a></span>
<span id="cb14-576"><a href="#cb14-576"></a><span class="in">    # Initialize labels</span></span>
<span id="cb14-577"><a href="#cb14-577"></a><span class="in">    initialize_labels_kernel(dev)(mask_gpu, labels_gpu, width, height, depth, ndrange = ndrange)</span></span>
<span id="cb14-578"><a href="#cb14-578"></a><span class="in">    CUDA.synchronize()</span></span>
<span id="cb14-579"><a href="#cb14-579"></a></span>
<span id="cb14-580"><a href="#cb14-580"></a><span class="in">    # Propagate labels iteratively</span></span>
<span id="cb14-581"><a href="#cb14-581"></a><span class="in">    for _ in 1:10 </span></span>
<span id="cb14-582"><a href="#cb14-582"></a><span class="in">        propagate_labels_kernel(dev, workgroupsize)(mask_gpu, labels_gpu, width, height, depth, ndrange = ndrange)</span></span>
<span id="cb14-583"><a href="#cb14-583"></a><span class="in">        CUDA.synchronize()</span></span>
<span id="cb14-584"><a href="#cb14-584"></a><span class="in">    end</span></span>
<span id="cb14-585"><a href="#cb14-585"></a></span>
<span id="cb14-586"><a href="#cb14-586"></a><span class="in">    # Download labels back to CPU</span></span>
<span id="cb14-587"><a href="#cb14-587"></a><span class="in">    labels_cpu = Array(labels_gpu)</span></span>
<span id="cb14-588"><a href="#cb14-588"></a><span class="in">    </span></span>
<span id="cb14-589"><a href="#cb14-589"></a><span class="in">    # Find all unique labels and their sizes</span></span>
<span id="cb14-590"><a href="#cb14-590"></a><span class="in">    unique_labels = unique(labels_cpu)</span></span>
<span id="cb14-591"><a href="#cb14-591"></a><span class="in">    label_sizes = [(label, count(labels_cpu .== label)) for label in unique_labels if label != 0]</span></span>
<span id="cb14-592"><a href="#cb14-592"></a></span>
<span id="cb14-593"><a href="#cb14-593"></a><span class="in">    # Sort labels by size and get the top n_lcc</span></span>
<span id="cb14-594"><a href="#cb14-594"></a><span class="in">    sort!(label_sizes, by = x -&gt; x[2], rev = true)</span></span>
<span id="cb14-595"><a href="#cb14-595"></a><span class="in">    top_labels = label_sizes[1:min(n_lcc, length(label_sizes))]</span></span>
<span id="cb14-596"><a href="#cb14-596"></a></span>
<span id="cb14-597"><a href="#cb14-597"></a><span class="in">    # Create a mask for each of the top n_lcc components</span></span>
<span id="cb14-598"><a href="#cb14-598"></a><span class="in">    components = [labels_cpu .== label[1] for label in top_labels]</span></span>
<span id="cb14-599"><a href="#cb14-599"></a><span class="in">    return components</span></span>
<span id="cb14-600"><a href="#cb14-600"></a><span class="in">end</span></span>
<span id="cb14-601"><a href="#cb14-601"></a><span class="in">```</span></span>
<span id="cb14-602"><a href="#cb14-602"></a>&lt;/details&gt;</span>
<span id="cb14-603"><a href="#cb14-603"></a></span>
<span id="cb14-604"><a href="#cb14-604"></a><span class="fu">## Structured configuration of all hyperparameters ğŸ†™</span></span>
<span id="cb14-605"><a href="#cb14-605"></a></span>
<span id="cb14-606"><a href="#cb14-606"></a>Hyperparameters for the entire pipeline are stored in a JSON configuration file, enabling straightforward adjustments for experimentation (just swap values, save and resume the study). This structured setup allows easy modification of key parameters, such as data set preparation, training settings, data augmentation, and resampling options.</span>
<span id="cb14-607"><a href="#cb14-607"></a></span>
<span id="cb14-608"><a href="#cb14-608"></a></span>
<span id="cb14-609"><a href="#cb14-609"></a>&lt;details&gt;</span>
<span id="cb14-610"><a href="#cb14-610"></a>&lt;summary&gt;Example configuration:&lt;/summary&gt;</span>
<span id="cb14-611"><a href="#cb14-611"></a></span>
<span id="cb14-612"><a href="#cb14-612"></a><span class="in">```JSON</span></span>
<span id="cb14-613"><a href="#cb14-613"></a><span class="fu">{</span></span>
<span id="cb14-614"><a href="#cb14-614"></a>    <span class="dt">"model"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-615"><a href="#cb14-615"></a>        <span class="dt">"patience"</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span></span>
<span id="cb14-616"><a href="#cb14-616"></a>        <span class="dt">"early_stopping_metric"</span><span class="fu">:</span> <span class="st">"val_loss"</span><span class="fu">,</span></span>
<span id="cb14-617"><a href="#cb14-617"></a>        <span class="dt">"optimizer_name"</span><span class="fu">:</span> <span class="st">"Adam"</span><span class="fu">,</span></span>
<span id="cb14-618"><a href="#cb14-618"></a>        <span class="dt">"loss_function_name"</span><span class="fu">:</span> <span class="st">"l1"</span><span class="fu">,</span></span>
<span id="cb14-619"><a href="#cb14-619"></a>        <span class="dt">"early_stopping"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb14-620"><a href="#cb14-620"></a>        <span class="dt">"early_stopping_min_delta"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.01</span><span class="fu">,</span></span>
<span id="cb14-621"><a href="#cb14-621"></a>        <span class="dt">"optimizer_args"</span><span class="fu">:</span> <span class="st">"lr=0.001"</span><span class="fu">,</span></span>
<span id="cb14-622"><a href="#cb14-622"></a>        <span class="dt">"num_epochs"</span><span class="fu">:</span> <span class="dv">10</span></span>
<span id="cb14-623"><a href="#cb14-623"></a>    <span class="fu">},</span></span>
<span id="cb14-624"><a href="#cb14-624"></a>    <span class="dt">"data"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-625"><a href="#cb14-625"></a>        <span class="dt">"batch_complete"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-626"><a href="#cb14-626"></a>        <span class="dt">"resample_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">200</span><span class="ot">,</span><span class="dv">101</span><span class="ot">,</span><span class="dv">49</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-627"><a href="#cb14-627"></a>        <span class="dt">"resample_to_target"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-628"><a href="#cb14-628"></a>        <span class="dt">"resample_to_spacing"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-629"><a href="#cb14-629"></a>        <span class="dt">"batch_size"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb14-630"><a href="#cb14-630"></a>        <span class="dt">"standardization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-631"><a href="#cb14-631"></a>        <span class="dt">"target_spacing"</span><span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span></span>
<span id="cb14-632"><a href="#cb14-632"></a>        <span class="dt">"channel_size"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb14-633"><a href="#cb14-633"></a>        <span class="dt">"normalization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-634"><a href="#cb14-634"></a>        <span class="dt">"has_mask"</span><span class="fu">:</span> <span class="kw">true</span></span>
<span id="cb14-635"><a href="#cb14-635"></a>    <span class="fu">},</span></span>
<span id="cb14-636"><a href="#cb14-636"></a>    <span class="dt">"augmentation"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-637"><a href="#cb14-637"></a>        <span class="dt">"augmentations"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-638"><a href="#cb14-638"></a>            <span class="dt">"Brightness transform"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-639"><a href="#cb14-639"></a>                <span class="dt">"mode"</span><span class="fu">:</span> <span class="st">"additive"</span><span class="fu">,</span></span>
<span id="cb14-640"><a href="#cb14-640"></a>                <span class="dt">"value"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb14-641"><a href="#cb14-641"></a>            <span class="fu">}</span></span>
<span id="cb14-642"><a href="#cb14-642"></a>        <span class="fu">},</span></span>
<span id="cb14-643"><a href="#cb14-643"></a>        <span class="dt">"p_rand"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">5</span><span class="fu">,</span></span>
<span id="cb14-644"><a href="#cb14-644"></a>        <span class="dt">"processing_unit"</span><span class="fu">:</span> <span class="st">"GPU"</span><span class="fu">,</span></span>
<span id="cb14-645"><a href="#cb14-645"></a>        <span class="dt">"order"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb14-646"><a href="#cb14-646"></a>            <span class="st">"Brightness transform"</span></span>
<span id="cb14-647"><a href="#cb14-647"></a>        <span class="ot">]</span></span>
<span id="cb14-648"><a href="#cb14-648"></a>    <span class="fu">},</span></span>
<span id="cb14-649"><a href="#cb14-649"></a>    <span class="dt">"learning"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-650"><a href="#cb14-650"></a>        <span class="dt">"Train_Val_Test_JSON"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-651"><a href="#cb14-651"></a>        <span class="dt">"largest_connected_component"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-652"><a href="#cb14-652"></a>        <span class="dt">"n_lcc"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb14-653"><a href="#cb14-653"></a>        <span class="dt">"n_folds"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb14-654"><a href="#cb14-654"></a>        <span class="dt">"invertible_augmentations"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-655"><a href="#cb14-655"></a>        <span class="dt">"n_invertible"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb14-656"><a href="#cb14-656"></a>        </span>
<span id="cb14-657"><a href="#cb14-657"></a>        <span class="dt">"class_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-658"><a href="#cb14-658"></a>        <span class="dt">"additional_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-659"><a href="#cb14-659"></a>        <span class="dt">"patch_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-660"><a href="#cb14-660"></a>        <span class="dt">"metric"</span><span class="fu">:</span> <span class="st">"dice"</span><span class="fu">,</span></span>
<span id="cb14-661"><a href="#cb14-661"></a>        <span class="dt">"n_cross_val"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-662"><a href="#cb14-662"></a>        <span class="dt">"patch_probabilistic_oversampling"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-663"><a href="#cb14-663"></a>        <span class="dt">"oversampling_probability"</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span></span>
<span id="cb14-664"><a href="#cb14-664"></a>        <span class="dt">"test_train_validation"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb14-665"><a href="#cb14-665"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">6</span><span class="ot">,</span></span>
<span id="cb14-666"><a href="#cb14-666"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span><span class="ot">,</span></span>
<span id="cb14-667"><a href="#cb14-667"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb14-668"><a href="#cb14-668"></a>        <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-669"><a href="#cb14-669"></a>        <span class="dt">"shuffle"</span><span class="fu">:</span> <span class="kw">false</span></span>
<span id="cb14-670"><a href="#cb14-670"></a>    <span class="fu">}</span></span>
<span id="cb14-671"><a href="#cb14-671"></a><span class="fu">}</span></span>
<span id="cb14-672"><a href="#cb14-672"></a></span>
<span id="cb14-673"><a href="#cb14-673"></a><span class="in">```</span></span>
<span id="cb14-674"><a href="#cb14-674"></a>&lt;/details&gt;</span>
<span id="cb14-675"><a href="#cb14-675"></a></span>
<span id="cb14-676"><a href="#cb14-676"></a>Comments:&lt;br&gt;</span>
<span id="cb14-677"><a href="#cb14-677"></a>The current configuration is loaded as a dictionary, which simplifies access and modification. This setup presents a strong foundation for integrating automated search algorithms for hyperparameter tuning, enabling more efficient model optimization.&lt;br&gt;</span>
<span id="cb14-678"><a href="#cb14-678"></a>The configuration structure could be re-organized and re-named to improve readability, making it easier for users to locate and adjust specific parameters.</span>
<span id="cb14-679"><a href="#cb14-679"></a></span>
<span id="cb14-680"><a href="#cb14-680"></a><span class="fu">## Visualization of algorithm outputs âš ï¸</span></span>
<span id="cb14-681"><a href="#cb14-681"></a>This module provides basic visualization functionality by saving output masks and images first to MedImage format and then to Nifti format. The <span class="in">`create_nii_from_medimage`</span> function from MedImage.jl generates Nifti files, which can be loaded into MedEye3D for 3D visualization.</span>
<span id="cb14-682"><a href="#cb14-682"></a></span>
<span id="cb14-683"><a href="#cb14-683"></a>Comments:&lt;br&gt;</span>
<span id="cb14-684"><a href="#cb14-684"></a>Integrating this visualization module more fully with the pipeline could eliminate unnecessary steps. By automatically loading output masks and images in as raw data into MedEye3D for 3D visualization and supporting a more efficient end-to-end workflow. </span>
<span id="cb14-685"><a href="#cb14-685"></a></span>
<span id="cb14-686"><a href="#cb14-686"></a><span class="fu">## K-fold cross-validation functionality âœ…</span></span>
<span id="cb14-687"><a href="#cb14-687"></a>K-fold cross-validation is implemented to evaluate model performance more robustly. The data is split into multiple folds, with each fold serving as a validation set once, while the others form the training set. This functionality provides a better assessment of model performance across different subsets of the data.</span>
<span id="cb14-688"><a href="#cb14-688"></a></span>
<span id="cb14-689"><a href="#cb14-689"></a>&lt;details&gt;</span>
<span id="cb14-690"><a href="#cb14-690"></a>&lt;summary&gt;K-fold cross-validation functionality:&lt;/summary&gt;</span>
<span id="cb14-691"><a href="#cb14-691"></a></span>
<span id="cb14-692"><a href="#cb14-692"></a><span class="in">```julia</span></span>
<span id="cb14-693"><a href="#cb14-693"></a><span class="in">...</span></span>
<span id="cb14-694"><a href="#cb14-694"></a><span class="in">  tstate = initialize_train_state(rng, model, optimizer)</span></span>
<span id="cb14-695"><a href="#cb14-695"></a><span class="in">  if config["learning"]["n_cross_val"]</span></span>
<span id="cb14-696"><a href="#cb14-696"></a><span class="in">      n_folds = config["learning"]["n_folds"]</span></span>
<span id="cb14-697"><a href="#cb14-697"></a><span class="in">      all_tstate = []</span></span>
<span id="cb14-698"><a href="#cb14-698"></a><span class="in">      combined_indices = [indices_dict["train"]; indices_dict["validation"]]</span></span>
<span id="cb14-699"><a href="#cb14-699"></a><span class="in">      shuffled_indices = shuffle(rng, combined_indices)</span></span>
<span id="cb14-700"><a href="#cb14-700"></a><span class="in">      for fold in 1:n_folds</span></span>
<span id="cb14-701"><a href="#cb14-701"></a><span class="in">          println("Starting fold $fold/$n_folds")</span></span>
<span id="cb14-702"><a href="#cb14-702"></a><span class="in">          train_groups, validation_groups = k_fold_split(combined_indices, n_folds, fold, rng)</span></span>
<span id="cb14-703"><a href="#cb14-703"></a><span class="in">          </span></span>
<span id="cb14-704"><a href="#cb14-704"></a><span class="in">          tstate = initialize_train_state(rng, model, optimizer)</span></span>
<span id="cb14-705"><a href="#cb14-705"></a><span class="in">          final_tstate = epoch_loop(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span></span>
<span id="cb14-706"><a href="#cb14-706"></a><span class="in">          </span></span>
<span id="cb14-707"><a href="#cb14-707"></a><span class="in">          push!(all_tstate, final_tstate)</span></span>
<span id="cb14-708"><a href="#cb14-708"></a><span class="in">      end</span></span>
<span id="cb14-709"><a href="#cb14-709"></a><span class="in">  else</span></span>
<span id="cb14-710"><a href="#cb14-710"></a><span class="in">      final_tstate = epoch_loop(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span></span>
<span id="cb14-711"><a href="#cb14-711"></a><span class="in">  end</span></span>
<span id="cb14-712"><a href="#cb14-712"></a><span class="in">  return final_tstate</span></span>
<span id="cb14-713"><a href="#cb14-713"></a><span class="in">...  </span></span>
<span id="cb14-714"><a href="#cb14-714"></a><span class="in">```</span></span>
<span id="cb14-715"><a href="#cb14-715"></a>&lt;/details&gt;</span>
<span id="cb14-716"><a href="#cb14-716"></a></span>
<span id="cb14-717"><a href="#cb14-717"></a>The <span class="in">`k_fold_split`</span> function organizes the indices for each fold, ensuring comprehensive coverage of the dataset during training.</span>
<span id="cb14-718"><a href="#cb14-718"></a></span>
<span id="cb14-719"><a href="#cb14-719"></a>&lt;details&gt;</span>
<span id="cb14-720"><a href="#cb14-720"></a>&lt;summary&gt;k_fold_split&lt;/summary&gt;</span>
<span id="cb14-721"><a href="#cb14-721"></a></span>
<span id="cb14-722"><a href="#cb14-722"></a><span class="in">```julia</span></span>
<span id="cb14-723"><a href="#cb14-723"></a><span class="in">function k_fold_split(data, n_folds, current_fold)</span></span>
<span id="cb14-724"><a href="#cb14-724"></a><span class="in">    fold_size = length(data) Ã· n_folds</span></span>
<span id="cb14-725"><a href="#cb14-725"></a><span class="in">    validation_start = (current_fold - 1) * fold_size + 1</span></span>
<span id="cb14-726"><a href="#cb14-726"></a><span class="in">    validation_end = validation_start + fold_size - 1</span></span>
<span id="cb14-727"><a href="#cb14-727"></a><span class="in">    validation_indices = data[validation_start:validation_end]</span></span>
<span id="cb14-728"><a href="#cb14-728"></a><span class="in">    train_indices = [data[1:validation_start-1]; data[validation_end+1:end]]</span></span>
<span id="cb14-729"><a href="#cb14-729"></a><span class="in">    return train_indices, validation_indices</span></span>
<span id="cb14-730"><a href="#cb14-730"></a><span class="in">end</span></span>
<span id="cb14-731"><a href="#cb14-731"></a><span class="in">```</span></span>
<span id="cb14-732"><a href="#cb14-732"></a>&lt;/details&gt;</span>
<span id="cb14-733"><a href="#cb14-733"></a></span>
<span id="cb14-734"><a href="#cb14-734"></a><span class="fu"># Conclusions and Future Development</span></span>
<span id="cb14-735"><a href="#cb14-735"></a>I have successfully established a foundation for a medical imaging pipeline, addressing significant challenges in data handling, model training, and augmentation integration. The integration of dataset-wide functions has significantly enhanced the reproducibility and handling batched data with GPU supporrt enables scalability of experiments, making it easier for researchers and practitioners to produce better results.</span>
<span id="cb14-736"><a href="#cb14-736"></a></span>
<span id="cb14-737"><a href="#cb14-737"></a><span class="fu"># Future Development</span></span>
<span id="cb14-738"><a href="#cb14-738"></a>As we look to the future, there are several areas where MedPipe3D can be expanded and improved to better serve the medical AI community. These include:</span>
<span id="cb14-739"><a href="#cb14-739"></a></span>
<span id="cb14-740"><a href="#cb14-740"></a><span class="fu">## Necessary Enhancements</span></span>
<span id="cb14-741"><a href="#cb14-741"></a></span>
<span id="cb14-742"><a href="#cb14-742"></a>Comprehensive Logging: Develop detailed logging mechanisms that capture a wide range of events, including system statuses, model performance metrics, and user activities, to facilitate debugging and system optimization. This is currently executed as a simple println function.</span>
<span id="cb14-743"><a href="#cb14-743"></a></span>
<span id="cb14-744"><a href="#cb14-744"></a><span class="co">&lt;!--</span></span>
<span id="cb14-745"><a href="#cb14-745"></a><span class="co">   - </span><span class="al">TODO</span><span class="co">: Could you link to TensorBoard?</span></span>
<span id="cb14-746"><a href="#cb14-746"></a><span class="co">   --&gt;</span></span>
<span id="cb14-747"><a href="#cb14-747"></a></span>
<span id="cb14-748"><a href="#cb14-748"></a>TensorBoard Integration: Implement an interface for TensorBoard to allow users to visualize training dynamics in real-time, providing insights into model behavior and performance trends.</span>
<span id="cb14-749"><a href="#cb14-749"></a></span>
<span id="cb14-750"><a href="#cb14-750"></a>Error and Warning Logs: Introduce advanced error and warning logging capabilities to alert users of potential issues before they affect the pipeline's performance, ensuring smoother operations and maintenance.</span>
<span id="cb14-751"><a href="#cb14-751"></a></span>
<span id="cb14-752"><a href="#cb14-752"></a>Automated Visualization: Integrate MedEye3D directly into MedPipe3D to enable automated visualization of outputs, such as segmentation masks or other relevant medical imaging features. This feature would provide users with real time visual feedback on model performance and data quality.</span>
<span id="cb14-753"><a href="#cb14-753"></a>Code-Level Documentation: Due to needed changes in the fundamental structure of pipeline in the final phase of the project, it is necessary to reevaluate all documentation.</span>
<span id="cb14-754"><a href="#cb14-754"></a></span>
<span id="cb14-755"><a href="#cb14-755"></a><span class="co">&lt;!--</span></span>
<span id="cb14-756"><a href="#cb14-756"></a><span class="co">   - </span><span class="al">TODO</span><span class="co">: Could you add a link here to the website?</span></span>
<span id="cb14-757"><a href="#cb14-757"></a><span class="co">   --&gt;</span></span>
<span id="cb14-758"><a href="#cb14-758"></a></span>
<span id="cb14-759"><a href="#cb14-759"></a>Official JuliaHealth Documentation: Extend the documentation efforts to include official entries on juliahealth.org, providing a centralized and authoritative resource for users seeking to learn more about MedPipe3D and its capabilities with examples shown</span>
<span id="cb14-760"><a href="#cb14-760"></a></span>
<span id="cb14-761"><a href="#cb14-761"></a><span class="fu">## Potential Enhancements</span></span>
<span id="cb14-762"><a href="#cb14-762"></a>GPU support for interpolation will allow to significantly accelerate such functions as: Scale transform, Simulate, Low-resolution transform, Elastic deformation transform, Resampling spacing</span>
<span id="cb14-763"><a href="#cb14-763"></a></span>
<span id="cb14-764"><a href="#cb14-764"></a>Add more reversible augmentations to test time </span>
<span id="cb14-765"><a href="#cb14-765"></a></span>
<span id="cb14-766"><a href="#cb14-766"></a>Calculating the average of the edges of the picture: hecking the type of photo and calculating more correctly on this basis</span>
<span id="cb14-767"><a href="#cb14-767"></a></span>
<span id="cb14-768"><a href="#cb14-768"></a>Elastic deformation transform with simulation of different tissue elasticities</span>
<span id="cb14-769"><a href="#cb14-769"></a></span>
<span id="cb14-770"><a href="#cb14-770"></a><span class="fu"># Acknowledgments ğŸ™‡â€â™‚ï¸</span></span>
<span id="cb14-771"><a href="#cb14-771"></a></span>
<span id="cb14-772"><a href="#cb14-772"></a>I would like to express my deepest gratitude to my mentor Dr. <span class="co">[</span><span class="ot">Jakub Mitura</span><span class="co">](https://www.linkedin.com/in/jakub-mitura-7b2013151/)</span> for his invaluable guidance and support throughout this project. His expertise and encouragement were instrumental in overcoming challenges and achieving project milestones.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, JuliaHealth.</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JuliaHealth/JuliaHealthBlog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/c/TheJuliaLanguage">
      <i class="bi bi-youtube" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml">
      <i class="bi bi-rss" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://julialang.org/slack/">
      <i class="bi bi-slack" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/julialanguage">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/edit/main/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>